<!DOCTYPE html>
<html lang="th" data-theme="studio-blue">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0F172A" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Mobile RTA (Pro)</title>

  <style>
    /* --- Theme: Studio Blue (default) --- */
    :root, [data-theme="studio-blue"] {
      --bg1:#0F172A; --bg2:#1E293B; --card:#1E293B; --text:#E2E8F0; --muted:#64748B;
      --gridH:rgba(255,255,255,.1); --gridV:rgba(255,255,255,.05);
      --frame:rgba(255,255,255,.12); --label:rgba(255,255,255,.85);
      --fft:#22D3EE; --peak:#A5B4FC; --hold:#F472B6; --bar:#22D3EE;
      --heatmap-color-1:#0F172A; --heatmap-color-2:#334155; --heatmap-color-3:#0EA5E9;
      --heatmap-color-4:#A78BFA; --heatmap-color-5:#F472B6;
      --dba-meter-bg-green:#22D3EE; --dba-meter-bg-yellow:#A78BFA; --dba-meter-bg-orange:#EC4899; --dba-meter-bg-red:#F43F5E;
      --accent-color:#60A5FA;
    }
    /* --- Theme: Dark Matter --- */
    [data-theme="dark-matter"]{
      --bg1:#1a202c; --bg2:#1a202c; --card:#2d3748; --text:#cbd5e1; --muted:#718096;
      --gridH:rgba(255,255,255,.08); --gridV:rgba(255,255,255,.04);
      --frame:rgba(255,255,255,.1); --label:rgba(255,255,255,.85);
      --fft:#68d391; --peak:#b794f4; --hold:#f6ad55; --bar:#68d391;
      --heatmap-color-1:#1a202c; --heatmap-color-2:#4a5568; --heatmap-color-3:#68d391;
      --heatmap-color-4:#f6ad55; --heatmap-color-5:#e53e3e;
      --dba-meter-bg-green:#48bb78; --dba-meter-bg-yellow:#f6ad55; --dba-meter-bg-orange:#ed8936; --dba-meter-bg-red:#e53e3e;
      --accent-color:#2DD4BF;
    }
    /* --- Theme: Vintage Amber --- */
    [data-theme="vintage-amber"]{
      --bg1:#292524; --bg2:#1c1917; --card:#44403C; --text:#D6D3D1; --muted:#A8A29E;
      --gridH:rgba(255,250,235,.1); --gridV:rgba(255,250,235,.05);
      --frame:rgba(255,250,235,.12); --label:rgba(255,255,255,.85);
      --fft:#F59E0B; --peak:#FDE68A; --hold:#FDBA74; --bar:#F59E0B;
      --heatmap-color-1:#292524; --heatmap-color-2:#78716C; --heatmap-color-3:#F59E0B;
      --heatmap-color-4:#FBBF24; --heatmap-color-5:#EF4444;
      --dba-meter-bg-green:#F59E0B; --dba-meter-bg-yellow:#FACC15; --dba-meter-bg-orange:#FB923C; --dba-meter-bg-red:#EF4444;
      --accent-color:#D97706;
    }

    :root{ color-scheme:dark }
    html{ background:var(--bg1) }
    body{
      margin:0; height:100%;
      background:radial-gradient(1200px 600px at 70% -10%, var(--card) 10%, var(--bg1) 60%, var(--bg2) 100%);
      color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans Thai",sans-serif;
      -webkit-touch-callout:none; -webkit-user-select:none; user-select:none; overscroll-behavior:contain;
      transition: background .3s, color .3s;
    }
    /* Safe-area filler */
    body::before,body::after{content:"";position:fixed;left:0;right:0;z-index:999;background:var(--bg1);pointer-events:none}
    body::before{top:0;height:env(safe-area-inset-top)} body::after{bottom:0;height:env(safe-area-inset-bottom)}
    @supports(padding: env(safe-area-inset-left)){
      html::before,html::after{content:"";position:fixed;top:0;bottom:0;background:var(--bg1);z-index:998;pointer-events:none}
      html::before{left:0;width:env(safe-area-inset-left)} html::after{right:0;width:env(safe-area-inset-right)}
    }
    .wrap{display:flex;flex-direction:column;gap:12px;max-width:920px;margin:0 auto;
      padding-left:calc(12px + env(safe-area-inset-left));
      padding-right:calc(12px + env(safe-area-inset-right));
      padding-top:calc(12px + env(safe-area-inset-top));
      padding-bottom:calc(12px + env(safe-area-inset-bottom));
    }
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .card{background:var(--card);border:1px solid rgba(255,255,255,.1);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:12px; transition: background-color .3s, border-color .3s;}
    button,select,input[type=range],input[type=number]{-webkit-tap-highlight-color:transparent}
    button{background:var(--accent-color);border:none;color:white;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer;transition:background-color .2s, opacity .2s;}
    button:disabled{opacity:.5;cursor:not-allowed;}
    button.secondary{background:rgba(0,0,0,.2);} button.ghost{background:rgba(0,0,0,.2);}
    label{font-size:12px;color:var(--muted)}
    .meters{display:grid;grid-template-columns:1fr;gap:12px}
    canvas{width:100%;height:320px;background:var(--bg1);border-radius:12px;touch-action:none; display: block; transition: background-color .3s;}

    .hint{font-size:12px;color:var(--muted)}
    .kv{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
    .kv div{background:rgba(0,0,0,.2);border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:8px}
    .kv b{display:block;color:var(--text);font-size:12px;margin-bottom:4px}
    .badges{display:flex;justify-content:center;gap:6px;}
    .badge{padding:4px 8px;border-radius:999px;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);font-size:12px;color:#e5e7eb;white-space:nowrap}
    .tip{position:absolute;padding:4px 6px;font-size:12px;color:#e5e7eb;background:rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.12);border-radius:8px;transform:translate(-50%,-100%);pointer-events:none;white-space:nowrap;z-index:10}
    .plot{position:relative; height: 320px; margin-top: 8px;}

    /* dB meter */
    #dbMeterContainer{position:relative;background:rgba(255,255,255,.1);border-radius:999px;overflow:hidden}
    #dbMeterCanvas{height:20px;background:transparent;border-radius:999px}
    .dbLabel{position:absolute;font-size:10px;color:var(--muted);bottom:4px}
    .dba-values-row{display:flex;justify-content:space-between;gap:8px}
    .dba-values-row .kv-item{flex:1;background:rgba(0,0,0,.2);border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:8px;text-align:center}
    .dba-values-row .kv-item b{display:block;color:var(--text);font-size:12px;margin-bottom:4px}
    input[type="range"], input[type="checkbox"] { accent-color: var(--accent-color); }

    /* --- Icon-only fullscreen button --- */
    .icon-btn{background:rgba(0,0,0,.28); width:34px; height:34px; border-radius:10px; display:inline-grid; place-items:center; padding:0;}
    .icon{font-size:18px; line-height:1;}
    .card-header-right{margin-left:auto; display:flex; gap:6px; align-items:center}

    /* --- Fullscreen card --- */
    body.is-fullscreen, html.is-fullscreen{overflow:hidden;}
    .fullscreen-card{
      position:fixed; z-index:10000; inset:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      margin:0 !important; border-radius:0 !important; padding:10px; display:flex; flex-direction:column; gap:8px;
      width:auto; height:auto; background:var(--card);
    }
    /* Height helpers for iOS (fallback when dvh not supported) */
    .fullscreen-card{ height:calc(var(--vh, 1vh) * 100); }
    @supports (height: 100dvh) {
      .fullscreen-card{ height:calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom)); }
    }
    .fullscreen-card .plot{ flex:1; height:auto; margin:0; }
    .fullscreen-card canvas{ height:100% !important; }

    /* little title bar when fullscreen */
    .fs-title {font-weight:700; color:var(--text); opacity:.9}
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Error banner -->
    <div id="errBox" class="card" style="display:none;border-color:#e53e3e;background:#1c2430">
      <b style="color:#fca5a5">‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏±‡∏î‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ</b>
      <div id="errMsg" class="hint" style="color:#fca5a5">‚Äî</div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;align-items:center;">
        <h2 style="margin:0 0 4px 0">my RTAs (v1.0)</h2>
        <div class="row">
          <button id="btnStart">‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏±‡∏î</button>
          <button id="btnStop" class="secondary" disabled>‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î</button>
          <button id="btnHold" class="ghost" aria-pressed="true">üìå Hold Peak: ON</button>
          <button id="btnClear" class="secondary">‚ôªÔ∏è Clear Peak</button>
          <button id="btnAWeight" class="ghost" aria-pressed="false">A-weighting: OFF</button>
        </div>
      </div>

      <div class="row" style="margin-top:8px">
        <label> Smoothing <input id="smoothing" type="range" min="0" max="0.95" step="0.01" value="0.75"></label>
        <label> Averaging <input id="avg" type="checkbox" checked></label>
      </div>

      <div class="row" style="justify-content:space-between;">
        <div class="row">
            <label>‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏õ‡∏¥‡∏î DSP ‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö:</label>
            <div class="row">
              <label>echoCancellation <input id="ec" type="checkbox" checked></label>
              <label>noiseSuppression <input id="ns" type="checkbox" checked></label>
              <label>autoGainControl <input id="agc" type="checkbox" checked></label>
            </div>
        </div>
        <label>Theme
           <select id="themeSelector">
              <option value="studio-blue" selected>Studio Blue</option>
              <option value="dark-matter">Dark Matter</option>
              <option value="vintage-amber">Vintage Amber</option>
           </select>
        </label>
      </div>
    </div>

    <div class="meters">
      <!-- FFT -->
      <div class="card" id="fftCard">
        <div class="row" style="align-items:center;">
          <b>RTA FFT - Log</b>
          <div class="badges"><span class="badge" id="fftPeakText">Peak: ‚Äî</span><span class="badge" id="fftHoldText" style="display:none;">Hold: ‚Äî</span></div>
          <div class="card-header-right">
            <label>FFT Size
              <input id="fftRangeSlider" type="range" min="0" max="3" step="1" value="1">
              <select id="fftSizePreset">
                <option value="2048">2048</option><option value="4096" selected>4096</option><option value="8192">8192</option><option value="16384">16384</option>
              </select>
            </label>
            <button id="btnFullFft" class="icon-btn" title="‡∏Ç‡∏¢‡∏≤‡∏¢"><span class="icon">‚§¢</span></button>
          </div>
        </div>
        <div class="plot">
          <canvas id="fftCanvas"></canvas>
          <div id="fftTip" class="tip" style="display:none">‚Äî</div>
        </div>
      </div>

      <!-- Octave -->
      <div class="card" id="octCard">
        <div class="row" style="align-items:center;">
          <div class="row">
            <b>RTA </b>
            <select id="octRes"><option value="3">1/3</option><option value="6">1/6</option><option value="12" selected>1/12</option></select>
            <b id="octTitle">Octave</b>
          </div>
          <div class="badges"><span class="badge" id="octPeakText">Peak: ‚Äî</span><span class="badge" id="octHoldText" style="display:none;">Hold: ‚Äî</span></div>
          <div class="card-header-right">
            <label style="display:flex;align-items:center;gap:6px">Range
              <input id="octRangeSlider" type="range" min="64" max="1023" step="1" value="255" aria-label="Octave bar range">
              <select id="octRangePreset"><option value="127">127</option><option value="255" selected>256</option><option value="511">512</option></select>
            </label>
            <span class="hint" id="octRangeText">0‚Äì255</span>
            <button id="btnFullOct" class="icon-btn" title="‡∏Ç‡∏¢‡∏≤‡∏¢"><span class="icon">‚§¢</span></button>
          </div>
        </div>
        <div class="plot">
          <canvas id="octCanvas"></canvas>
          <div id="octTip" class="tip" style="display:none">‚Äî</div>
        </div>
      </div>

      <!-- Spectrogram -->
      <div class="card" id="heatmapCard">
        <div class="row" style="align-items:center;">
          <div class="row">
            <b id="heatmapTitle">Spectrogram</b>
            <button id="btnToggleHeatmap" class="ghost" aria-pressed="false">OFF</button>
            <button id="btnHeatmapQuality" class="ghost" aria-pressed="true">HD</button>
          </div>
          <div class="badges">
            <span class="badge" id="heatmapAthText">ATH: ‚Äî</span>
            <button id="btnClearAth" class="ghost" style="font-size:12px;padding:4px 8px; margin-left:4px;">Clear</button>
          </div>
          <div class="card-header-right">
            <label style="display:flex;align-items:center;gap:6px">Range
              <input id="heatmapRangeSlider" type="range" min="5" max="100" step="5" value="50" aria-label="Heatmap range">
              <select id="heatmapRangePreset">
                <option value="5">5</option><option value="10">10</option><option value="20">20</option><option value="40">40</option>
                <option value="50" selected>50</option><option value="60">60</option><option value="80">80</option><option value="100">100</option>
              </select>
            </label>
            <span class="hint" id="heatmapRangeText">-50 dBFS</span>
            <button id="btnFullHeat" class="icon-btn" title="‡∏Ç‡∏¢‡∏≤‡∏¢"><span class="icon">‚§¢</span></button>
          </div>
        </div>
        <div class="plot">
          <canvas id="heatmapCanvas"></canvas>
          <div id="heatmapTip" class="tip" style="display:none">‚Äî</div>
        </div>
      </div>

      <!-- dBA -->
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
          <b>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏±‡∏á‡∏£‡∏ß‡∏° dB</b>
          <button id="btnResetDba" class="secondary" style="font-size:12px;padding:6px 10px;">‚ôªÔ∏è Reset AVG/MAX</button>
        </div>
        <div id="dbMeterContainer">
          <canvas id="dbMeterCanvas"></canvas>
          <span class="dbLabel" style="left:0%">0</span>
          <span class="dbLabel" style="left:28.57%">40</span>
          <span class="dbLabel" style="left:57.14%">80</span>
          <span class="dbLabel" style="left:85.71%">120</span>
          <span class="dbLabel" style="right:0">140</span>
        </div>
        <div class="dba-values-row" style="margin-top:12px;">
          <div class="kv-item"><b>Realtime (dB)</b><span id="dbRealtimeValue">‚Äî</span></div>
          <div class="kv-item"><b>AVG (dB)</b><span id="dbAvgValue">‚Äî</span></div>
          <div class="kv-item"><b>MAX (dB)</b><span id="dbMaxValue">‚Äî</span></div>
        </div>
      </div>
    </div>

    <div class="card kv">
      <div><b>‡∏£‡∏∞‡∏î‡∏±‡∏ö RMS (‡∏î‡∏¥‡∏ö dBFS)</b><span id="rms">‚Äî</span></div>
      <div><b>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏û‡∏µ‡∏Ñ‡πÇ‡∏î‡∏¢‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì</b><span id="peak">‚Äî</span></div>
    </div>

    <div class="card row" style="justify-content:space-between;align-items:center;margin-top:0">
      <div class="hint">‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏≠‡∏≠‡∏ü‡πÄ‡∏ã‡πá‡∏ï‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏õ‡∏•‡∏á dBFS ‡πÄ‡∏õ‡πá‡∏ô dBA (‡∏à‡∏≤‡∏Å‡πÑ‡∏°‡∏Ñ‡πå‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠)</div>
      <label>Calibration Offset (dB) <input id="calibrationOffset" type="number" min="0" step="0.1" value="100" style="width:60px;padding:4px;border-radius:6px;border:1px solid #4a5568;background:#2d3748;color:white;"></label>
    </div>

    <div id="fsTitleBar" class="row" style="display:none; position:fixed; top:calc(env(safe-area-inset-top) + 8px); left:calc(env(safe-area-inset-left) + 12px); z-index:10001;">
      <span class="fs-title" id="fsTitle">‚Äî</span>
      <button id="btnExitFs" class="icon-btn" style="margin-left:8px;" title="‡∏¢‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö"><span class="icon">‚§°</span></button>
    </div>
  </div>

  <script>
  (() => {
    /*** viewport height fix for iOS ***/
    const setVhVar = () => {
      document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px');
    };
    setVhVar();
    window.addEventListener('resize', setVhVar);
    window.addEventListener('orientationchange', () => { setTimeout(()=>{ setVhVar(); rta?.handleResize(); }, 120); });

    class RTAnalyzer {
      constructor() {
        this.PAD = { L: 40, R: 10, T: 10, B: 32 };
        this.LABEL_Y = 10;
        this.HEATMAP_TIME_SLICES = 200;
        this.HEATMAP_BINS_HD = 300;
        this.HEATMAP_BINS_SD = 60;
        this.FFT_SIZES = [2048, 4096, 8192, 16384];

        this.dom = this.getDOMElements();
        this.colors = {};
        
        this.state = {
          audioCtx: null, analyser: null, micSrc: null, stream: null, rafId: null,
          dataArray: null, freqArray: null,
          sampleRate: 48000,
          running: false,
          holdEnabled: true,
          aWeightOn: false,
          heatmapEnabled: false,
          heatmapIsHD: true,
          peakArray: null, peakOct: null, 
          athHeatmap: { value: -Infinity, bin: 0 },
          avgBuffer: null,
          octN: 12, bands: [],
          heatmapData: [], heatmapFreqBinMap: null,
          lastHeatmapUpdate: 0,
          calibrationOffset: 100,
          maxDba: -Infinity, dbaValues: [],
          octRangeMax: 255, heatmapRangeMax: 50,
          guideFFT: null, guideOCT: null, guideHeatmap: null,
          fullscreenTarget: null
        };
        
        this.init();
      }

      init() {
        this.applyTheme('studio-blue');
        this.setupEventListeners();
        this.setupCanvases();
        this.updateOctaveRangeText();
        this.updateHeatmapRangeText();
        this.drawInitialFrames();
      }

      getStyle(p) { return getComputedStyle(document.documentElement).getPropertyValue(p).trim(); }

      getDOMElements() {
        const ids = [
          'btnStart', 'btnStop', 'btnHold', 'btnClear', 'btnToggleHeatmap', 'btnHeatmapQuality', 'btnResetDba', 'btnClearAth', 'btnAWeight',
          'fftSizePreset', 'smoothing', 'avg', 'ec', 'ns', 'agc', 'themeSelector', 'fftRangeSlider',
          'fftPeakText', 'fftHoldText', 'octPeakText', 'octHoldText', 'heatmapAthText',
          'fftCanvas', 'octCanvas', 'heatmapCanvas', 'dbMeterCanvas',
          'fftTip', 'octTip', 'heatmapTip',
          'dbRealtimeValue', 'dbAvgValue', 'dbMaxValue',
          'calibrationOffset', 'octTitle', 'octRes',
          'octRangePreset', 'octRangeSlider', 'octRangeText',
          'heatmapRangeSlider', 'heatmapRangePreset', 'heatmapRangeText',
          'rms', 'peak', 'errBox', 'errMsg',
          'btnFullFft','btnFullOct','btnFullHeat','fftCard','octCard','heatmapCard','fsTitleBar','fsTitle','btnExitFs'
        ];
        const dom = {};
        ids.forEach(id => dom[id] = document.getElementById(id));
        return dom;
      }

      setupEventListeners() {
        this.dom.btnStart.addEventListener('click', () => this.start());
        this.dom.btnStop.addEventListener('click', () => this.stop());
        this.dom.btnClear.addEventListener('click', () => this.clearPeak());
        this.dom.btnResetDba.addEventListener('click', () => this.resetDbaValues());

        this.dom.btnAWeight.addEventListener('click', () => {
          this.state.aWeightOn = !this.state.aWeightOn;
          this.dom.btnAWeight.setAttribute('aria-pressed', this.state.aWeightOn);
          this.dom.btnAWeight.textContent = `A-weighting: ${this.state.aWeightOn ? 'ON' : 'OFF'}`;
        });
        
        this.dom.btnHold.addEventListener('click', () => {
          this.state.holdEnabled = !this.state.holdEnabled;
          this.dom.btnHold.setAttribute('aria-pressed', this.state.holdEnabled);
          this.dom.btnHold.textContent = `üìå Hold Peak: ${this.state.holdEnabled ? 'ON' : 'OFF'}`;
        });

        this.dom.btnToggleHeatmap.addEventListener('click', () => {
          this.state.heatmapEnabled = !this.state.heatmapEnabled;
          this.dom.btnToggleHeatmap.setAttribute('aria-pressed', this.state.heatmapEnabled);
          this.dom.btnToggleHeatmap.textContent = this.state.heatmapEnabled ? 'ON' : 'OFF';
          if (!this.state.heatmapEnabled) this.drawHeatmapOverlay();
        });
        
        this.dom.btnHeatmapQuality.addEventListener('click', () => {
          this.state.heatmapIsHD = !this.state.heatmapIsHD;
          this.dom.btnHeatmapQuality.setAttribute('aria-pressed', this.state.heatmapIsHD);
          this.dom.btnHeatmapQuality.textContent = this.state.heatmapIsHD ? 'HD' : 'SD';
          this.state.heatmapFreqBinMap = this.genHeatmapBins();
          this.state.heatmapData = [];
          if (this.state.heatmapEnabled) this.drawHeatmap(true); else this.drawHeatmapOverlay();
        });

        this.dom.btnClearAth.addEventListener('click', () => {
          this.state.athHeatmap = { value: -Infinity, bin: 0 };
          this.dom.heatmapAthText.textContent = 'ATH: ‚Äî';
        });

        this.dom.themeSelector.addEventListener('change', (e) => this.applyTheme(e.target.value));

        this.dom.fftSizePreset.addEventListener('change', (e) => {
          const selectedValue = e.target.value;
          const index = this.FFT_SIZES.indexOf(parseInt(selectedValue, 10));
          this.dom.fftRangeSlider.value = index;
          this.onConfigChange();
        });
        this.dom.fftRangeSlider.addEventListener('input', (e) => {
          const index = parseInt(e.target.value, 10);
          const fftSize = this.FFT_SIZES[index];
          this.dom.fftSizePreset.value = fftSize;
          this.onConfigChange();
        });
        
        this.dom.smoothing.addEventListener('input', () => {
          if (this.state.analyser) this.state.analyser.smoothingTimeConstant = parseFloat(this.dom.smoothing.value);
        });
        
        this.dom.octRes.addEventListener('change', () => {
          this.state.octN = parseInt(this.dom.octRes.value, 10);
          this.state.bands = this.genBands(this.state.octN);
          this.state.peakOct = new Float32Array(this.state.bands.length);
        });
        
        [this.dom.ec, this.dom.ns, this.dom.agc].forEach(el => el.addEventListener('change', () => {
          if (this.state.running) {
            this.stop(); setTimeout(() => this.start(), 50);
          }
        }));
        
        this.dom.calibrationOffset.addEventListener('input', () => {
          this.state.calibrationOffset = parseFloat(this.dom.calibrationOffset.value) || 100;
        });

        this.dom.octRangePreset.addEventListener('change', (e) => {
          this.state.octRangeMax = parseInt(e.target.value, 10);
          this.dom.octRangeSlider.value = this.state.octRangeMax;
          this.updateOctaveRangeText();
        });
        this.dom.octRangeSlider.addEventListener('input', (e) => {
          this.state.octRangeMax = parseInt(e.target.value, 10);
          this.updateOctaveRangeText();
        });
        this.dom.heatmapRangePreset.addEventListener('change', (e) => {
          this.state.heatmapRangeMax = parseInt(e.target.value, 10);
          this.dom.heatmapRangeSlider.value = this.state.heatmapRangeMax;
          this.updateHeatmapRangeText();
        });
        this.dom.heatmapRangeSlider.addEventListener('input', () => {
          this.state.heatmapRangeMax = parseInt(this.dom.heatmapRangeSlider.value, 10);
          this.updateHeatmapRangeText();
        });

        // Fullscreen buttons
        this.dom.btnFullFft.addEventListener('click', () => this.toggleFullscreen(this.dom.fftCard, 'FFT'));
        this.dom.btnFullOct.addEventListener('click', () => this.toggleFullscreen(this.dom.octCard, 'Octave'));
        this.dom.btnFullHeat.addEventListener('click', () => this.toggleFullscreen(this.dom.heatmapCard, 'Spectrogram'));
        this.dom.btnExitFs.addEventListener('click', () => this.toggleFullscreen(null));

        window.addEventListener('resize', () => this.handleResize());
      }
      
      setupCanvases() {
        this.canvases = {
          fft: { canvas: this.dom.fftCanvas, ctx: this.dom.fftCanvas.getContext('2d'), tip: this.dom.fftTip },
          oct: { canvas: this.dom.octCanvas, ctx: this.dom.octCanvas.getContext('2d'), tip: this.dom.octTip },
          heatmap: { canvas: this.dom.heatmapCanvas, ctx: this.dom.heatmapCanvas.getContext('2d'), tip: this.dom.heatmapTip },
          dbMeter: { canvas: this.dom.dbMeterCanvas, ctx: this.dom.dbMeterCanvas.getContext('2d') }
        };
        this.handleResize();
        this.attachPressGuide(this.canvases.fft, 'fft');
        this.attachPressGuide(this.canvases.oct, 'oct');
        this.attachPressGuide(this.canvases.heatmap, 'heatmap');
      }

      handleResize() {
        const dpr = window.devicePixelRatio || 1;
        for (const key in this.canvases) {
          if (!this.canvases[key] || !this.canvases[key].canvas) continue;
          const { canvas, ctx } = this.canvases[key];
          const rect = canvas.getBoundingClientRect();
          canvas.width = Math.max(1, rect.width * dpr);
          canvas.height = Math.max(1, rect.height * dpr);
          if (ctx) { ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.scale(dpr, dpr); }
        }
        this.drawInitialFrames();
        if (this.state.running) {
          this.drawFFT(); this.drawOctave(); if (this.state.heatmapEnabled) this.drawHeatmap(true);
        }
      }

      drawInitialFrames() {
        this.drawBackground(this.canvases.fft.ctx);
        this.drawBackground(this.canvases.oct.ctx);
        this.drawHeatmapBackground(this.canvases.heatmap.ctx);
        this.drawHeatmapOverlay();
        this.drawDbMeterBackground();
      }
      
      async start() {
        this.dom.btnStart.disabled = true;
        try {
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö getUserMedia API');
          }
          const constraints = { audio: { 
            echoCancellation: { ideal: this.dom.ec.checked },
            noiseSuppression: { ideal: this.dom.ns.checked },
            autoGainControl: { ideal: this.dom.agc.checked }
          }};

          let stream;
          try {
            stream = await navigator.mediaDevices.getUserMedia(constraints);
          } catch (e) {
            try { stream = await navigator.mediaDevices.getUserMedia({ audio: true }); }
            catch (e2) { this.showError(`‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÑ‡∏°‡∏Ñ‡πå‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: ${e2.message || e2}`); this.dom.btnStart.disabled = false; return; }
          }

          const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
          if (audioCtx.state === 'suspended') await audioCtx.resume();

          const analyser = audioCtx.createAnalyser();
          const micSrc = audioCtx.createMediaStreamSource(stream);
          micSrc.connect(analyser);

          this.state = { ...this.state, audioCtx, analyser, micSrc, stream, running: true };
          
          this.onConfigChange();
          this.resetDbaValues();
          this.dom.errBox.style.display = 'none';
          this.dom.btnStop.disabled = false;
          
          this.loop();

        } catch (err) {
          console.error(err);
          this.showError(err.message || String(err));
          this.dom.btnStart.disabled = false;
        }
      }

      stop() {
        if (!this.state.running) return;
        this.state.running = false;
        cancelAnimationFrame(this.state.rafId);

        this.state.stream?.getTracks().forEach(track => track.stop());
        this.state.micSrc?.disconnect();
        this.state.analyser?.disconnect();
        try { this.state.audioCtx?.close(); } catch(_){}

        this.state = { ...this.state, audioCtx: null, analyser: null, micSrc: null, stream: null };
        
        this.dom.btnStart.disabled = false;
        this.dom.btnStop.disabled = true;
        this.dom.dbRealtimeValue.textContent = '‚Äî';
        this.updateDbMeter(-Infinity);
      }
      
      onConfigChange() {
        if (!this.state.analyser) return;
        this.state.analyser.fftSize = parseInt(this.dom.fftSizePreset.value, 10);
        this.state.analyser.smoothingTimeConstant = parseFloat(this.dom.smoothing.value);
        
        this.state.dataArray = new Uint8Array(this.state.analyser.fftSize);
        this.state.freqArray = new Uint8Array(this.state.analyser.frequencyBinCount);
        this.state.peakArray = new Uint8Array(this.state.analyser.frequencyBinCount);
        this.state.avgBuffer = new Float32Array(this.state.analyser.frequencyBinCount);
        
        this.state.sampleRate = this.state.audioCtx.sampleRate;
        this.state.bands = this.genBands(this.state.octN);
        this.state.peakOct = new Float32Array(this.state.bands.length);
        this.state.heatmapFreqBinMap = this.genHeatmapBins();
        this.state.heatmapData = [];
        this.state.athHeatmap = { value: -Infinity, bin: 0 };
      }

      loop() {
        if (!this.state.running) return;

        this.state.analyser.getByteTimeDomainData(this.state.dataArray);
        this.state.analyser.getByteFrequencyData(this.state.freqArray);
        
        if (this.dom.avg.checked) {
          const a = 0.5;
          for (let i = 0; i < this.state.freqArray.length; i++) {
            this.state.avgBuffer[i] = a * this.state.avgBuffer[i] + (1 - a) * this.state.freqArray[i];
            this.state.freqArray[i] = this.state.avgBuffer[i];
          }
        }
        
        this.drawFFT();
        this.drawOctave();
        this.updateRMS();
        this.updateDba();

        const now = performance.now();
        if (this.state.heatmapEnabled && (now - this.state.lastHeatmapUpdate >= 33)) {
          this.drawHeatmap();
          this.state.lastHeatmapUpdate = now;
        }

        this.state.rafId = requestAnimationFrame(() => this.loop());
      }
      
      clamp01(v) { return Math.min(1, Math.max(0, v)); }
      dbfs(v) { return 20 * Math.log10(v / 255 + 1e-12); }
      fmtHz(f) { return f >= 1000 ? ((f / 1000 >= 10 ? (f / 1000).toFixed(0) : (f / 1000).toFixed(1)) + ' kHz') : (Math.round(f) + ' Hz'); }
      aWeighting(f) { const f2 = f * f; const ra = (12200 ** 2 * f2 ** 2) / ((f2 + 20.6 ** 2) * (f2 + 12200 ** 2) * Math.sqrt((f2 + 107.7 ** 2) * (f2 + 737.9 ** 2))); return 20 * Math.log10(ra) + 2.0; }
      fmax() { return Math.min(this.state.sampleRate / 2, 20000); }
      mapLogX(f, w) { const fm = this.fmax(); const fmin = 20; const t = (Math.log10(Math.max(f, fmin)) - Math.log10(fmin)) / (Math.log10(fm) - Math.log10(fmin)); return this.PAD.L + t * (w - this.PAD.L - this.PAD.R); }
      xToFreq(x, w) { const fm = this.fmax(); const fmin = 20; const plotW = w - this.PAD.L - this.PAD.R; const t = this.clamp01((x - this.PAD.L) / plotW); const lf = Math.log10(fmin) + t * (Math.log10(fm) - Math.log10(fmin)); return Math.pow(10, lf); }
      mapDbToY(db, h) { const norm = this.clamp01((db + 100) / 100); const plotH = h - this.PAD.T - this.PAD.B; return this.PAD.T + (1 - norm) * plotH; }
      mapLinearToYOct(v, h) { const norm = this.clamp01(v / Math.max(1, this.state.octRangeMax)); const plotH = h - this.PAD.T - this.PAD.B; return this.PAD.T + (1 - norm) * plotH; }
      mapDbToColorHeatmap(db) {
        const maxDb = 0; const minDb = maxDb - this.state.heatmapRangeMax;
        const t = this.clamp01((db - minDb) / (maxDb - minDb));
        if (t < 0.25) return this.colors.heatmap[0]; if (t < 0.5) return this.colors.heatmap[1];
        if (t < 0.75) return this.colors.heatmap[2]; if (t < 0.9) return this.colors.heatmap[3];
        return this.colors.heatmap[4];
      }

      genBands(n) {
        const r = Math.pow(2, 1 / n), fm = this.fmax(), fmin = 20;
        const kmin = Math.ceil(Math.log(fmin / 1000) / Math.log(r));
        const kmax = Math.floor(Math.log(fm / 1000) / Math.log(r));
        const edgeHalf = Math.pow(2, 1 / (2 * n));
        const arr = [];
        for (let k = kmin; k <= kmax; k++) {
          const fc = 1000 * Math.pow(r, k), fl = fc / edgeHalf, fh = fc * edgeHalf;
          if (fh < fmin || fl > fm) continue;
          arr.push({ fc, fl: Math.max(fl, fmin), fh: Math.min(fh, fm) });
        }
        return arr;
      }

      genHeatmapBins() {
        if (!this.state.analyser) return null;
        const numBins = this.state.heatmapIsHD ? this.HEATMAP_BINS_HD : this.HEATMAP_BINS_SD;
        const fm = this.fmax(), fpb = this.state.sampleRate / this.state.analyser.fftSize, fmin = 20;
        const logFmin = Math.log10(fmin), logFmax = Math.log10(fm);
        const bins = [];
        for (let i = 0; i < numBins; i++) {
          const logFs = logFmin + (i / numBins) * (logFmax - logFmin);
          const logFe = logFmin + ((i + 1) / numBins) * (logFmax - logFmin);
          const fStart = Math.pow(10, logFs), fEnd = Math.pow(10, logFe);
          const binStart = Math.max(0, Math.floor(fStart / fpb));
          const binEnd = Math.min(this.state.analyser.frequencyBinCount - 1, Math.ceil(fEnd / fpb));
          bins.push({ binStart, binEnd, fStart, fEnd });
        }
        return bins;
      }
      
      drawBackground(ctx) {
        const { width: w, height: h } = ctx.canvas;
        const dpr = window.devicePixelRatio || 1;
        const plotW = w / dpr, plotH = h / dpr;
        ctx.clearRect(0, 0, plotW, plotH);
        const plotAreaH = plotH - this.PAD.T - this.PAD.B;
        ctx.strokeStyle = this.colors.gridH;
        for (let i = 0; i < 6; i++) { const y = this.PAD.T + (i / 5) * plotAreaH; ctx.beginPath(); ctx.moveTo(this.PAD.L, y); ctx.lineTo(plotW - this.PAD.R, y); ctx.stroke(); }
        ctx.strokeStyle = this.colors.gridV;
        const ticks = [20, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000, 2000, 4000, 8000, 16000];
        ticks.forEach(t => { const x = this.mapLogX(t, plotW); ctx.beginPath(); ctx.moveTo(x, this.PAD.T); ctx.lineTo(x, this.PAD.T + plotAreaH); ctx.stroke(); });
        ctx.strokeStyle = this.colors.frame; ctx.strokeRect(this.PAD.L, this.PAD.T, plotW - this.PAD.L - this.PAD.R, plotAreaH);
        ctx.fillStyle = this.colors.label; ctx.font = '12px system-ui'; ctx.textBaseline = 'alphabetic';
        [31.5, 63, 125, 250, 500, 1000, 2000, 4000, 8000, 16000].forEach(t => { const x = this.mapLogX(t, plotW); ctx.fillText(t >= 1000 ? (t / 1000) + 'k' : t, x - 8, plotH - this.LABEL_Y); });
      }
      
      drawFFT() {
        const { ctx } = this.canvases.fft;
        const { width: w, height: h } = ctx.canvas;
        const dpr = window.devicePixelRatio || 1;
        const plotW = w / dpr, plotH = h / dpr;
        this.drawBackground(ctx);
        if (!this.state.freqArray) return;
        const N = this.state.freqArray.length, fpb = this.state.sampleRate / (2 * N);
        if (this.state.holdEnabled) {
          for (let i = 0; i < N; i++) this.state.peakArray[i] = Math.max(this.state.peakArray[i], this.state.freqArray[i]);
        }
        ctx.beginPath(); let started = false;
        for (let i = 1; i < N; i++) {
          const f = i * fpb; if (f < 20 || f > this.fmax()) continue;
          const x = this.mapLogX(f, plotW), y = this.mapDbToY(this.dbfs(this.state.freqArray[i]), plotH);
          if (!started) { ctx.moveTo(x, y); started = true; } else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = this.colors.fft; ctx.lineWidth = 2; ctx.stroke();

        ctx.beginPath(); started = false;
        for (let i = 1; i < N; i++) {
          const f = i * fpb; if (f < 20 || f > this.fmax()) continue;
          const x = this.mapLogX(f, plotW), y = this.mapDbToY(this.dbfs(this.state.peakArray[i] || 0), plotH);
          if (!started) { ctx.moveTo(x, y); started = true; } else ctx.lineTo(x, y);
        }
        ctx.save(); ctx.globalAlpha = .35; ctx.strokeStyle = this.colors.peak; ctx.lineWidth = 1.25; ctx.stroke(); ctx.restore();

        let peakBin = 0, peakVal = -Infinity; for (let i = 0; i < N; i++) if (this.state.freqArray[i] > peakVal) { peakVal = this.state.freqArray[i]; peakBin = i; }
        const peakFreqNow = peakBin * fpb;
        this.dom.peak.textContent = this.fmtHz(peakFreqNow);
        this.dom.fftPeakText.textContent = `Peak: ${this.fmtHz(peakFreqNow)}`;

        let holdBin = 0, holdVal = 0; for (let i = 0; i < N; i++) if (this.state.peakArray[i] > holdVal) { holdVal = this.state.peakArray[i]; holdBin = i; }
        if (holdVal > 0) {
          this.dom.fftHoldText.style.display = '';
          const holdHz = this.fmtHz(holdBin * fpb);
          this.dom.fftHoldText.textContent = `Hold: ${holdHz}`;
          this.drawPeakLine(ctx, this.mapLogX(holdBin * fpb, plotW), plotW, plotH, this.colors.hold, true, holdHz);
        } else {
          this.dom.fftHoldText.style.display = 'none';
        }

        this.drawPeakLine(ctx, this.mapLogX(peakFreqNow, plotW), plotW, plotH, 'rgba(100,149,237,.6)');
        if (this.state.guideFFT) this.drawGuide(ctx, this.state.guideFFT.xPx, plotH);
      }

      drawOctave() {
        const { ctx } = this.canvases.oct;
        const { width: w, height: h } = ctx.canvas;
        const dpr = window.devicePixelRatio || 1;
        const plotW = w / dpr, plotH = h / dpr;
        this.drawBackground(ctx);
        if (!this.state.freqArray || !this.state.bands.length) return;
        const N = this.state.freqArray.length, fpb = this.state.sampleRate / (2 * N);
        const vals = this.state.bands.map(b => {
          const s = Math.max(0, Math.floor(b.fl / fpb)), e = Math.min(N - 1, Math.ceil(b.fh / fpb));
          let sum = 0, cnt = 0;
          for (let i = s; i <= e; i++) { sum += this.state.freqArray[i]; cnt++; }
          let v = cnt ? (sum / cnt) : 0;
          if (this.state.aWeightOn) v *= Math.pow(10, this.aWeighting(b.fc) / 20);
          return v;
        });
        if (this.state.holdEnabled) {
          for (let i = 0; i < vals.length; i++) this.state.peakOct[i] = Math.max(this.state.peakOct[i], vals[i]);
        }
        ctx.fillStyle = this.colors.bar;
        for (let i = 0; i < vals.length; i++) {
          const b = this.state.bands[i];
          const xL = this.mapLogX(b.fl, plotW), xR = this.mapLogX(b.fh, plotW);
          const barW = Math.max(2, xR - xL - 2);
          const y = this.mapLinearToYOct(vals[i], plotH);
          const barH = (plotH - this.PAD.B - y);
          ctx.fillRect(xL + 1, y, barW, Math.max(1, barH));
        }
        ctx.beginPath();
        for (let i = 0; i < vals.length; i++) {
          const cx = this.mapLogX(this.state.bands[i].fc, plotW);
          const y = this.mapLinearToYOct(this.state.peakOct[i] || 0, plotH);
          if (i === 0) ctx.moveTo(cx, y); else ctx.lineTo(cx, y);
        }
        ctx.save(); ctx.globalAlpha = .45; ctx.strokeStyle = this.colors.hold; ctx.lineWidth = 1.5; ctx.stroke(); ctx.restore();

        let idxNow = 0, vNow = -1; for (let i = 0; i < vals.length; i++) if (vals[i] > vNow) { vNow = vals[i]; idxNow = i; }
        let idxHold = 0, vHold = 0; for (let i = 0; i < this.state.peakOct.length; i++) if (this.state.peakOct[i] > vHold) { vHold = this.state.peakOct[i]; idxHold = i; }
        this.dom.octPeakText.textContent = `Peak: ${this.fmtHz(this.state.bands[idxNow].fc)}`;
        if (vHold > 0) {
          this.dom.octHoldText.style.display = '';
          const holdHz = this.fmtHz(this.state.bands[idxHold].fc);
          this.dom.octHoldText.textContent = `Hold: ${holdHz}`;
          this.drawPeakLine(ctx, this.mapLogX(this.state.bands[idxHold].fc, plotW), plotW, plotH, this.colors.hold, true, holdHz);
        } else {
          this.dom.octHoldText.style.display = 'none';
        }
        this.drawPeakLine(ctx, this.mapLogX(this.state.bands[idxNow].fc, plotW), plotW, plotH, 'rgba(100,149,237,.6)');
        if (this.state.guideOCT) this.drawGuide(ctx, this.state.guideOCT.xPx, plotH);
      }

      drawHeatmap(forceRedraw = false) {
        const mainCtx = this.canvases.heatmap.ctx;
        const { width: w, height: h } = mainCtx.canvas;
        const dpr = window.devicePixelRatio || 1;
        const plotW = w / dpr, plotH = h / dpr;
        const plotAreaH = plotH - this.PAD.B;

        if (!this.state.freqArray || !this.state.heatmapFreqBinMap) return;

        const frame = this.state.heatmapFreqBinMap.map(bin => {
          let sum = 0, cnt = 0;
          for (let j = bin.binStart; j <= bin.binEnd; j++) { sum += this.state.freqArray[j]; cnt++; }
          const avgDb = cnt > 0 ? this.dbfs(sum / cnt) : -100;
          return { db: avgDb };
        });
        
        let currentPeakBin = 0, currentPeakVal = -Infinity;
        for (let i = 0; i < frame.length; i++) {
          if (frame[i].db > currentPeakVal) { currentPeakVal = frame[i].db; currentPeakBin = i; }
        }
        if (currentPeakVal > this.state.athHeatmap.value) {
          this.state.athHeatmap = { value: currentPeakVal, bin: currentPeakBin };
        }

        const athFreqBin = this.state.heatmapFreqBinMap[this.state.athHeatmap.bin];
        if (athFreqBin && this.state.athHeatmap.value > -Infinity) {
          const athFreq = (athFreqBin.fStart + athFreqBin.fEnd) / 2;
          this.dom.heatmapAthText.textContent = `ATH: ${this.fmtHz(athFreq)}`;
        } else {
          this.dom.heatmapAthText.textContent = 'ATH: ‚Äî';
        }

        this.state.heatmapData.unshift(frame);
        if (this.state.heatmapData.length > this.HEATMAP_TIME_SLICES) this.state.heatmapData.pop();
        
        this.drawHeatmapBackground(mainCtx);
        const timeScale = plotAreaH / this.HEATMAP_TIME_SLICES;
        for (let i = 0; i < this.state.heatmapData.length; i++) {
          const y = i * timeScale;
          const row = this.state.heatmapData[i];
          for (let j = 0; j < row.length; j++) {
            const { fStart, fEnd } = this.state.heatmapFreqBinMap[j];
            const xL = this.mapLogX(fStart, plotW), xR = this.mapLogX(fEnd, plotW);
            mainCtx.fillStyle = this.mapDbToColorHeatmap(row[j].db);
            mainCtx.fillRect(xL, y, Math.max(1, xR - xL), timeScale);
          }
        }
        
        this.drawHeatmapGrid(mainCtx);
        if (this.state.guideHeatmap) this.drawHeatmapGuide(mainCtx, this.state.guideHeatmap.xPx, plotH);
      }
      
      drawHeatmapBackground(ctx) {
        const { width: w, height: h } = ctx.canvas;
        const dpr = window.devicePixelRatio || 1;
        const plotW = w / dpr, plotH = h / dpr;
        ctx.clearRect(0, 0, plotW, plotH);
      }

      drawHeatmapGrid(ctx) {
        const { width: w, height: h } = ctx.canvas;
        const dpr = window.devicePixelRatio || 1;
        const plotW = w / dpr, plotH = h / dpr;
        const plotAreaH = plotH - this.PAD.B;
        ctx.strokeStyle = this.colors.frame;
        ctx.strokeRect(this.PAD.L, 0, plotW - this.PAD.L - this.PAD.R, plotAreaH);
        ctx.strokeStyle = this.colors.gridV;
        const ticks = [20, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000, 2000, 4000, 8000, 16000];
        ticks.forEach(t => { const x = this.mapLogX(t, plotW); ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, plotAreaH); ctx.stroke(); });
        ctx.fillStyle = this.colors.label; ctx.font = '12px system-ui'; ctx.textBaseline = 'alphabetic';
        [31.5, 63, 125, 250, 500, 1000, 2000, 4000, 8000, 16000].forEach(t => { const x = this.mapLogX(t, plotW); ctx.fillText(t >= 1000 ? (t / 1000) + 'k' : t, x - 8, plotH - this.LABEL_Y); });
      }

      drawHeatmapOverlay() {
        const { ctx } = this.canvases.heatmap;
        const { width: w, height: h } = ctx.canvas;
        const dpr = window.devicePixelRatio || 1;
        const plotW = w / dpr, plotH = h / dpr;
        this.drawHeatmapBackground(ctx);
        ctx.fillStyle = 'rgba(255,255,255,.4)';
        ctx.font = '24px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Heatmap OFF', plotW / 2, (plotH - this.PAD.B) / 2);
      }
      
      // --- Hold/Peak guide lines & labels ---
      drawPeakLine(ctx, x, wCss, hCss, color, dashed = false, labelText = null) {
        const y0 = this.PAD.T, y1 = hCss - this.PAD.B;
        ctx.save();
        ctx.strokeStyle = color; ctx.lineWidth = 1;
        if (dashed) ctx.setLineDash([5, 5]);
        ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y1); ctx.stroke();
        ctx.restore();

        if (!labelText) return;
        // label pill (clamped in-frame)
        ctx.save();
        ctx.font = '12px system-ui';
        const padX = 6, padY = 3;
        const textW = ctx.measureText(labelText).width;
        const boxW = textW + padX * 2, boxH = 18;
        let bx = Math.round(x - boxW / 2);
        const minX = this.PAD.L + 2, maxX = (wCss - this.PAD.R) - boxW - 2;
        if (bx < minX) bx = minX; if (bx > maxX) bx = maxX;
        const by = y0 + 2;
        ctx.fillStyle = 'rgba(0,0,0,.55)';
        ctx.strokeStyle = 'rgba(255,255,255,.2)'; ctx.lineWidth = 1;
        ctx.beginPath();
        const r = 8;
        ctx.moveTo(bx + r, by);
        ctx.lineTo(bx + boxW - r, by);
        ctx.quadraticCurveTo(bx + boxW, by, bx + boxW, by + r);
        ctx.lineTo(bx + boxW, by + boxH - r);
        ctx.quadraticCurveTo(bx + boxW, by + boxH, bx + boxW - r, by + boxH);
        ctx.lineTo(bx + r, by + boxH);
        ctx.quadraticCurveTo(bx, by + boxH, bx, by + boxH - r);
        ctx.lineTo(bx, by + r);
        ctx.quadraticCurveTo(bx, by, bx + r, by);
        ctx.closePath();
        ctx.fill(); ctx.stroke();
        ctx.fillStyle = this.colors.label || '#e5e7eb';
        ctx.textBaseline = 'middle'; ctx.textAlign = 'center';
        ctx.fillText(labelText, bx + boxW / 2, by + boxH / 2 + 0.5);
        ctx.restore();
      }

      drawGuide(ctx, x, h) { ctx.save(); ctx.strokeStyle = 'rgba(100,149,237,.75)'; ctx.setLineDash([4, 4]); ctx.beginPath(); ctx.moveTo(x, this.PAD.T); ctx.lineTo(x, h - this.PAD.B); ctx.stroke(); ctx.restore(); }
      drawHeatmapGuide(ctx, x, h) { ctx.save(); ctx.strokeStyle = 'rgba(100,149,237,.75)'; ctx.setLineDash([4, 4]); ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h - this.PAD.B); ctx.stroke(); ctx.restore(); }
      
      updateRMS() { if (!this.state.dataArray) return; let sum = 0; for (let i = 0; i < this.state.dataArray.length; i++) { const v = (this.state.dataArray[i] - 128) / 128; sum += v * v; } const rms = Math.sqrt(sum / this.state.dataArray.length); this.dom.rms.textContent = (20 * Math.log10(rms + 1e-12)).toFixed(1) + ' dBFS'; }
      calculateDba() { if (!this.state.freqArray || !this.state.analyser) return -Infinity; const N = this.state.freqArray.length, fpb = this.state.sampleRate / this.state.analyser.fftSize; let sum = 0; for (let i = 0; i < N; i++) { const f = i * fpb; const aw = Math.pow(10, this.aWeighting(f) / 20); const v = this.state.freqArray[i] * aw; sum += v * v; } const rms = Math.sqrt(sum / N); const dbfsValue = 20 * Math.log10(rms / 255 + 1e-12); return dbfsValue + this.state.calibrationOffset; }
      drawDbMeterBackground() { const { ctx } = this.canvases.dbMeter; const { width: w, height: h } = ctx.canvas; ctx.clearRect(0, 0, w, h); }
      
      updateDbMeter(db) {
        const { ctx } = this.canvases.dbMeter;
        const { width: w, height: h } = ctx.canvas;
        const dpr = window.devicePixelRatio || 1;
        const plotW = w / dpr, plotH = h / dpr;
        const dbMin = 0, dbMax = 140;
        const fillW = plotW * this.clamp01((db - dbMin) / (dbMax - dbMin));
        const g = ctx.createLinearGradient(0, 0, plotW, 0);
        g.addColorStop(0, this.colors.dbMeter.green);
        g.addColorStop(0.357, this.colors.dbMeter.green);
        g.addColorStop(0.571, this.colors.dbMeter.yellow);
        g.addColorStop(0.714, this.colors.dbMeter.orange);
        g.addColorStop(0.785, this.colors.dbMeter.red);
        g.addColorStop(1, this.colors.dbMeter.red);
        this.drawDbMeterBackground();
        ctx.fillStyle = g; ctx.fillRect(0, 0, fillW, plotH);
      }

      updateDba() {
        const dbAraw = this.calculateDba(), dbAdisp = Math.max(0, dbAraw);
        this.updateDbMeter(dbAdisp);
        if (this.state.dbaValues.length === 0) {
          if (dbAdisp > 0) {
            this.state.dbaValues.push(dbAdisp);
            this.dom.dbRealtimeValue.textContent = `${dbAdisp.toFixed(1)} dB`;
            this.dom.dbAvgValue.textContent = this.dom.dbMaxValue.textContent = `${dbAdisp.toFixed(1)} dB`;
            this.state.maxDba = dbAdisp;
          } else {
            this.dom.dbRealtimeValue.textContent = '‚Äî'; this.dom.dbAvgValue.textContent = '‚Äî'; this.dom.dbMaxValue.textContent = '‚Äî';
          }
        } else {
          this.dom.dbRealtimeValue.textContent = `${dbAdisp.toFixed(1)} dB`;
          if (dbAdisp > this.state.maxDba) { this.state.maxDba = dbAdisp; this.dom.dbMaxValue.textContent = `${this.state.maxDba.toFixed(1)} dB`; }
          if (dbAdisp > 0) { this.state.dbaValues.push(dbAdisp); if (this.state.dbaValues.length > 100) this.state.dbaValues.shift(); }
          const avg = this.state.dbaValues.reduce((a, b) => a + b, 0) / this.state.dbaValues.length;
          this.dom.dbAvgValue.textContent = `${avg.toFixed(1)} dB`;
        }
      }
      resetDbaValues() { this.state.maxDba = -Infinity; this.state.dbaValues = []; this.dom.dbRealtimeValue.textContent = '‚Äî'; this.dom.dbAvgValue.textContent = '‚Äî'; this.dom.dbMaxValue.textContent = '‚Äî'; }
      clearPeak() { this.state.peakArray?.fill(0); this.state.peakOct?.fill(0); }
      updateOctaveRangeText() { this.dom.octRangeText.textContent = `0‚Äì${this.state.octRangeMax}`; }
      updateHeatmapRangeText() { this.dom.heatmapRangeText.textContent = `-${this.state.heatmapRangeMax} dBFS`; }
      
      showError(msg) { this.dom.errBox.style.display = 'block'; this.dom.errMsg.textContent = msg; }

      attachPressGuide({ canvas, tip }, which) {
        let pressed = false;
        const getX = (e) => { const r = canvas.getBoundingClientRect(); const xCss = (e.touches ? e.touches[0].clientX : e.clientX) - r.left; return Math.max(this.PAD.L, Math.min(r.width - this.PAD.R, xCss)); };
        const update = (xPx) => {
          const freq = this.xToFreq(xPx, canvas.getBoundingClientRect().width);
          tip.style.display = 'block'; tip.textContent = this.fmtHz(freq);
          tip.style.left = xPx + 'px'; tip.style.top = '8px';
          const guideState = { xPx, freq };
          if (which === 'fft') this.state.guideFFT = guideState;
          else if (which === 'oct') this.state.guideOCT = guideState;
          else if (which === 'heatmap') this.state.guideHeatmap = guideState;
        };
        const clear = () => {
          pressed = false; tip.style.display = 'none';
          if (which === 'fft') this.state.guideFFT = null;
          else if (which === 'oct') this.state.guideOCT = null;
          else if (which === 'heatmap') this.state.guideHeatmap = null;
        };
        const onDown = (e) => { pressed = true; e.preventDefault(); update(getX(e)); };
        const onMove = (e) => { if (!pressed) return; e.preventDefault(); update(getX(e)); };
        const onUp = () => clear();
        canvas.addEventListener('mousedown', onDown); canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseup', onUp); canvas.addEventListener('mouseleave', onUp);
        canvas.addEventListener('touchstart', onDown, { passive: false });
        canvas.addEventListener('touchmove', onMove, { passive: false });
        canvas.addEventListener('touchend', onUp);
      }

      applyTheme(themeName) {
        document.documentElement.dataset.theme = themeName;
        setTimeout(() => {
          this.updateColors();
          this.drawInitialFrames();
          if (this.state.running) {
            this.drawFFT(); this.drawOctave(); if (this.state.heatmapEnabled) this.drawHeatmap(true);
          }
        }, 50);
      }

      updateColors() {
        this.colors = {
          gridH: this.getStyle('--gridH'), gridV: this.getStyle('--gridV'),
          frame: this.getStyle('--frame'), label: this.getStyle('--label'),
          fft: this.getStyle('--fft'), peak: this.getStyle('--peak'),
          hold: this.getStyle('--hold'), bar: this.getStyle('--bar'),
          heatmap: [
            this.getStyle('--heatmap-color-1'), this.getStyle('--heatmap-color-2'),
            this.getStyle('--heatmap-color-3'), this.getStyle('--heatmap-color-4'),
            this.getStyle('--heatmap-color-5')
          ],
          dbMeter: {
            green: this.getStyle('--dba-meter-bg-green'),
            yellow: this.getStyle('--dba-meter-bg-yellow'),
            orange: this.getStyle('--dba-meter-bg-orange'),
            red: this.getStyle('--dba-meter-bg-red')
          }
        };
      }

      /*** Fullscreen toggle ***/
      toggleFullscreen(cardEl, title = '') {
        // exit
        if (!cardEl || this.state.fullscreenTarget) {
          const target = this.state.fullscreenTarget;
          if (target) target.classList.remove('fullscreen-card');
          this.state.fullscreenTarget = null;
          document.body.classList.remove('is-fullscreen'); document.documentElement.classList.remove('is-fullscreen');
          this.dom.fsTitleBar.style.display = 'none';
          this.handleResize();
          return;
        }
        // enter
        cardEl.classList.add('fullscreen-card');
        this.state.fullscreenTarget = cardEl;
        document.body.classList.add('is-fullscreen'); document.documentElement.classList.add('is-fullscreen');
        this.dom.fsTitle.textContent = title;
        this.dom.fsTitleBar.style.display = 'flex';
        // wait next frame then resize canvases to new rect
        requestAnimationFrame(()=>this.handleResize());
      }
    }

    const rta = new RTAnalyzer();
  })();
  </script>
</body>
</html>

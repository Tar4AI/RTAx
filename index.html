<!DOCTYPE html>
<html lang="th" data-theme="studio-blue">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
<meta name="theme-color" content="#0F172A" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>my RTAs (v1.6)</title>
<style>
  :root{color-scheme:dark}
  /* ---------- Themes ---------- */
  [data-theme="studio-blue"]{
    --bg1:#0F172A; --bg2:#1E293B; --card:#1E293B; --text:#E2E8F0; --muted:#94A3B8;
    --gridH:rgba(255,255,255,.1); --gridV:rgba(255,255,255,.06);
    --frame:rgba(255,255,255,.12); --label:rgba(255,255,255,.8);
    --fft:#22D3EE; --peak:#A5B4FC; --hold:#F472B6; --bar:#22D3EE;
    --heatmap1:#0F172A; --heatmap2:#334155; --heatmap3:#0EA5E9; --heatmap4:#A78BFA; --heatmap5:#F472B6;
    --accent:#60A5FA;
    --dbg:#22D3EE; --dby:#A78BFA; --dbo:#EC4899; --dbr:#F43F5E;
  }
  [data-theme="dark-matter"]{
    --bg1:#1a202c; --bg2:#1a202c; --card:#2d3748; --text:#cbd5e1; --muted:#94A3B8;
    --gridH:rgba(255,255,255,.08); --gridV:rgba(255,255,255,.04);
    --frame:rgba(255,255,255,.1); --label:rgba(255,255,255,.8);
    --fft:#68d391; --peak:#b794f4; --hold:#f6ad55; --bar:#68d391;
    --heatmap1:#1a202c; --heatmap2:#4a5568; --heatmap3:#68d391; --heatmap4:#f6ad55; --heatmap5:#e53e3e;
    --accent:#2DD4BF;
    --dbg:#48bb78; --dby:#f6ad55; --dbo:#ed8936; --dbr:#e53e3e;
  }
  [data-theme="vintage-amber"]{
    --bg1:#292524; --bg2:#1c1917; --card:#44403C; --text:#D6D3D1; --muted:#C6C2BD;
    --gridH:rgba(255,250,235,.12); --gridV:rgba(255,250,235,.06);
    --frame:rgba(255,250,235,.12); --label:rgba(255,250,235,.85);
    --fft:#F59E0B; --peak:#FDE68A; --hold:#FDBA74; --bar:#F59E0B;
    --heatmap1:#292524; --heatmap2:#78716C; --heatmap3:#F59E0B; --heatmap4:#FBBF24; --heatmap5:#EF4444;
    --accent:#D97706;
    --dbg:#F59E0B; --dby:#FACC15; --dbo:#FB923C; --dbr:#EF4444;
  }

  html,body{height:100%}
  html{background:var(--bg1)}
  body{
    margin:0; color:var(--text);
    background:radial-gradient(1200px 600px at 70% -10%, var(--card) 10%, var(--bg1) 60%, var(--bg2) 100%);
    font-family: system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans Thai",sans-serif;
    -webkit-touch-callout:none; -webkit-user-select:none; user-select:none; overscroll-behavior-y:contain;
  }
  /* safe-area */
  body::before,body::after{content:"";position:fixed;left:0;right:0;background:var(--bg1);z-index:9999;pointer-events:none}
  body::before{top:0;height:env(safe-area-inset-top)} body::after{bottom:0;height:env(safe-area-inset-bottom)}
  @supports(padding: env(safe-area-inset-left)){
    html::before,html::after{content:"";position:fixed;top:0;bottom:0;background:var(--bg1);z-index:9998;pointer-events:none}
    html::before{left:0;width:env(safe-area-inset-left)} html::after{right:0;width:env(safe-area-inset-right)}
  }

  .wrap{max-width:1100px;margin:0 auto;padding:12px;display:flex;flex-direction:column;gap:12px}
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  .card{background:var(--card);border:1px solid rgba(255,255,255,.12);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:12px}
  .card-head{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px}
  .card-title{font-weight:700}
  .pill{padding:4px 8px;border-radius:999px;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);font-size:12px}
  .right{margin-left:auto}
  .plot{position:relative;height:320px;margin-top:6px}
  canvas{width:100%;height:100%;display:block;background:var(--bg1);border-radius:12px}
  label{font-size:12px;color:var(--muted)}
  select, input[type="number"]{background:rgba(0,0,0,.2);border:1px solid rgba(255,255,255,.12);color:var(--text);border-radius:8px;padding:4px 8px}
  input[type="range"],input[type="checkbox"]{accent-color:var(--accent)}
  button{border:0;border-radius:10px;background:var(--accent);color:#fff;font-weight:700;padding:8px 10px;cursor:pointer}
  button.ghost{background:rgba(0,0,0,.25)}
  button.icon{width:32px;height:32px;display:inline-grid;place-items:center;font-size:16px;border-radius:8px}
  .tip{position:absolute;padding:4px 6px;font-size:12px;color:#e5e7eb;background:rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.12);border-radius:8px;transform:translate(-50%,-100%);pointer-events:none;white-space:nowrap;z-index:5}
  /* --- floating dock --- */
  .float-dock{
    position:fixed; left:12px; top:50%; transform:translateY(-50%);
    display:flex; flex-direction:column; gap:10px; z-index:100000;
    background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.1); padding:8px; border-radius:12px;
    backdrop-filter: blur(8px);
  }
  .dock-btn{width:40px;height:40px;display:grid;place-items:center;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.35);color:#e5e7eb;font-size:18px}
  .dock-btn[aria-pressed="true"]{background:rgba(96,165,250,.35);box-shadow:0 0 0 2px rgba(96,165,250,.35) inset}
  .dock-btn:disabled{opacity:.5;cursor:not-allowed}
  /* --- fullscreen fallback --- */
  .card.is-fullscreen{
    position:fixed; inset:0; margin:0; border-radius:0; z-index:99990; padding:12px 12px calc(12px + env(safe-area-inset-bottom));
  }
  .card.is-fullscreen .plot{height:calc(100vh - 110px)} /* ‡∏´‡∏±‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î ~110px ‡πÇ‡∏î‡∏¢‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì */
  /* ‡∏õ‡∏∏‡πà‡∏°‡∏Ç‡∏¢‡∏≤‡∏¢‡∏Ç‡∏ß‡∏≤ */
  .fs-btn{width:34px;height:34px;border-radius:8px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);color:#e5e7eb}
  /* mobile fine-tune: ‡∏•‡∏î‡∏Ç‡∏≠‡∏ö‡∏•‡πà‡∏≤‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠ ‡πÉ‡∏´‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏¢‡∏≠‡∏∞‡∏Ç‡∏∂‡πâ‡∏ô */
  @media (max-width: 600px){
    .wrap{padding:10px}
    .card.is-fullscreen{padding:8px 8px calc(6px + env(safe-area-inset-bottom))}
    .card.is-fullscreen .plot{height:calc(100vh - 96px)}
    .float-dock{left:8px}
  }
</style>
</head>
<body>
  <!-- Floating Command Dock -->
  <div class="float-dock" id="floatDock">
    <button id="dockStart" class="dock-btn" title="‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏±‡∏î">‚ñ∂Ô∏è</button>
    <button id="dockStop"  class="dock-btn" title="‡∏´‡∏¢‡∏∏‡∏î" disabled>‚è∏Ô∏è</button>
    <button id="dockHold"  class="dock-btn" title="Hold Peak" aria-pressed="true">üìå</button>
    <button id="dockClear" class="dock-btn" title="‡∏•‡πâ‡∏≤‡∏á Hold">‚ôªÔ∏è</button>
    <button id="dockA"     class="dock-btn" title="A-weighting" aria-pressed="false">üëÇ</button>
  </div>

  <div class="wrap">
    <!-- Header Settings -->
    <div class="card">
      <div class="row" style="justify-content:space-between; width:100%">
        <div class="row">
          <h2 style="margin:0 8px 0 0">my RTAs (v1.6)</h2>
          <label> Smoothing
            <input id="smoothing" type="range" min="0" max="0.95" step="0.01" value="0.75">
          </label>
          <label> Averaging <input id="avg" type="checkbox" checked></label>
          <label>echoCancellation <input id="ec" type="checkbox" checked></label>
          <label>noiseSuppression <input id="ns" type="checkbox" checked></label>
          <label>autoGainControl <input id="agc" type="checkbox" checked></label>
        </div>
        <label>Theme
          <select id="themeSelector">
            <option value="studio-blue" selected>Studio Blue</option>
            <option value="dark-matter">Dark Matter</option>
            <option value="vintage-amber">Vintage Amber</option>
          </select>
        </label>
      </div>
    </div>

    <!-- FFT -->
    <div class="card" id="cardFFT">
      <div class="card-head">
        <div class="row">
          <span class="card-title">RTA FFT - Log</span>
          <span class="pill" id="fftPeakText" style="margin-left:10px">Peak: ‚Äî</span>
          <span class="pill" id="fftHoldText" style="margin-left:6px;display:none">Hold: ‚Äî</span>
        </div>
        <div class="row">
          <label>FFT Size
            <input id="fftSlider" type="range" min="0" max="3" step="1" value="1" style="vertical-align:middle">
            <select id="fftPreset">
              <option value="2048">2048</option>
              <option value="4096" selected>4096</option>
              <option value="8192">8192</option>
              <option value="16384">16384</option>
            </select>
          </label>
          <button class="fs-btn icon" id="fsFFT" title="‡∏Ç‡∏¢‡∏≤‡∏¢">‚õ∂</button>
        </div>
      </div>
      <div class="plot">
        <canvas id="fftCanvas"></canvas>
        <div id="fftTip" class="tip" style="display:none">‚Äî</div>
      </div>
    </div>

    <!-- Octave -->
    <div class="card" id="cardOCT">
      <div class="card-head">
        <div class="row">
          <span class="card-title">RTA <span class="pill" id="octResText">1/12</span> Octave</span>
          <span class="pill" id="octPeakText" style="margin-left:10px">Peak: ‚Äî</span>
          <span class="pill" id="octHoldText" style="margin-left:6px;display:none">Hold: ‚Äî</span>
        </div>
        <div class="row">
          <label>Res
            <select id="octRes" style="margin-right:8px">
              <option value="3">1/3</option>
              <option value="6">1/6</option>
              <option value="12" selected>1/12</option>
            </select>
          </label>
          <label>Range
            <input id="octRange" type="range" min="64" max="1023" step="1" value="255" style="vertical-align:middle">
            <select id="octRangePreset">
              <option value="127">127</option>
              <option value="255" selected>256</option>
              <option value="511">512</option>
            </select>
          </label>
          <button class="fs-btn icon" id="fsOCT" title="‡∏Ç‡∏¢‡∏≤‡∏¢">‚õ∂</button>
        </div>
      </div>
      <div class="plot">
        <canvas id="octCanvas"></canvas>
        <div id="octTip" class="tip" style="display:none">‚Äî</div>
      </div>
    </div>

    <!-- Spectrogram -->
    <div class="card" id="cardSPEC">
      <div class="card-head">
        <div class="row">
          <span class="card-title">Spectrogram</span>
          <span class="pill" id="heatmapAth">ATH: ‚Äî</span>
        </div>
        <div class="row">
          <button id="btnHeatOnOff" class="icon ghost" title="ON/OFF">OFF</button>
          <button id="btnHeatHD" class="icon ghost" aria-pressed="true" title="HD">HD</button>
          <label>Range
            <input id="heatRange" type="range" min="5" max="100" step="5" value="50">
            <select id="heatPreset">
              <option>5</option><option>10</option><option>20</option><option>40</option>
              <option selected>50</option><option>60</option><option>80</option><option>100</option>
            </select>
            <span class="pill" id="heatRangeText">-50 dBFS</span>
          </label>
          <button id="btnHeatClear" class="icon ghost" title="Clear ATH">üóò</button>
          <button class="fs-btn icon" id="fsSPEC" title="‡∏Ç‡∏¢‡∏≤‡∏¢">‚õ∂</button>
        </div>
      </div>
      <div class="plot">
        <canvas id="heatCanvas"></canvas>
        <div id="heatTip" class="tip" style="display:none">‚Äî</div>
      </div>
    </div>
  </div>

<script>
(() => {
  class RTAnalyzer{
    constructor(){
      /* --- constants --- */
      this.PAD = { L: 40, R: 10, T: 10, B: 32 };
      this.LABEL_Y = 10;
      this.FFT_SIZES = [2048,4096,8192,16384];
      this.HEAT_T = 220; this.HEAT_HD = 300; this.HEAT_SD = 60;

      /* --- DOM --- */
      const id = s=>document.getElementById(s);
      this.dom = {
        smoothing:id('smoothing'), avg:id('avg'), ec:id('ec'), ns:id('ns'), agc:id('agc'), themeSelector:id('themeSelector'),
        // dock
        dockStart:id('dockStart'), dockStop:id('dockStop'), dockHold:id('dockHold'), dockClear:id('dockClear'), dockA:id('dockA'),
        floatDock:id('floatDock'),
        // FFT
        cardFFT:id('cardFFT'), fsFFT:id('fsFFT'), fftCanvas:id('fftCanvas'), fftTip:id('fftTip'),
        fftSlider:id('fftSlider'), fftPreset:id('fftPreset'), fftPeakText:id('fftPeakText'), fftHoldText:id('fftHoldText'),
        // OCT
        cardOCT:id('cardOCT'), fsOCT:id('fsOCT'), octCanvas:id('octCanvas'), octTip:id('octTip'),
        octRes:id('octRes'), octResText:id('octResText'), octRange:id('octRange'), octRangePreset:id('octRangePreset'),
        octPeakText:id('octPeakText'), octHoldText:id('octHoldText'),
        // SPEC
        cardSPEC:id('cardSPEC'), fsSPEC:id('fsSPEC'), heatCanvas:id('heatCanvas'), heatTip:id('heatTip'),
        btnHeatOnOff:id('btnHeatOnOff'), btnHeatHD:id('btnHeatHD'), btnHeatClear:id('btnHeatClear'),
        heatPreset:id('heatPreset'), heatRange:id('heatRange'), heatRangeText:id('heatRangeText'), heatmapAth:id('heatmapAth'),
      };

      /* --- colors --- */
      this.colors = {};
      this.updateColors();

      /* --- state --- */
      this.state = {
        audioCtx:null, analyser:null, micSrc:null, stream:null, rafId:0,
        dataArray:null, freqArray:null, avgBuf:null, peakArray:null,
        sampleRate:48000, running:false, hold:true, aweight:false,
        // octave
        octN:12, bands:[], peakOct:null, octRangeMax:255,
        // spectrogram
        heatOn:false, heatHD:true, heatBins:null, heatData:[], heatRangeMax:50, ath:{v:-Infinity, i:0},
        // guides
        guideFFT:null, guideOCT:null, guideSPEC:null,
      };

      this.floatDockEl  = this.dom.floatDock;
      this.floatDockHome = this.floatDockEl.parentElement;

      /* init */
      this.applyTheme('studio-blue');
      this.setupCanvases();
      this.bindUI();
      this.drawAllStatic();
    }

    /* ---------- utils ---------- */
    getStyle(p){return getComputedStyle(document.documentElement).getPropertyValue(p).trim();}
    clamp01(v){return Math.min(1,Math.max(0,v));}
    dbfs(v){return 20*Math.log10(v/255+1e-12);}
    fmtHz(f){return f>=1000?((f/1000>=10?(f/1000).toFixed(0):(f/1000).toFixed(1))+' kHz'):(Math.round(f)+' Hz');}
    aWeighting(f){const f2=f*f;const ra=(12200**2*f2**2)/((f2+20.6**2)*(f2+12200**2)*Math.sqrt((f2+107.7**2)*(f2+737.9**2)));return 20*Math.log10(ra)+2.0;}
    fmax(){return Math.min(this.state.sampleRate/2,20000);}
    mapLogX(f,w){const fm=this.fmax(),fmin=20;const t=(Math.log10(Math.max(f,fmin))-Math.log10(fmin))/(Math.log10(fm)-Math.log10(fmin));return this.PAD.L+t*(w-this.PAD.L-this.PAD.R);}
    xToFreq(x,w){const fm=this.fmax(),fmin=20;const plotW=w-this.PAD.L-this.PAD.R;const t=this.clamp01((x-this.PAD.L)/plotW);const lf=Math.log10(fmin)+t*(Math.log10(fm)-Math.log10(fmin));return Math.pow(10,lf);}
    mapDbToY(db,h){const norm=this.clamp01((db+100)/100);const plotH=h-this.PAD.T-this.PAD.B;return this.PAD.T+(1-norm)*plotH;}
    mapLinearToYOct(v,h){const norm=this.clamp01(v/Math.max(1,this.state.octRangeMax));const plotH=h-this.PAD.T-this.PAD.B;return this.PAD.T+(1-norm)*plotH;}

    /* ---------- theme ---------- */
    applyTheme(name){
      document.documentElement.dataset.theme=name;
      setTimeout(()=>{this.updateColors(); this.drawAllStatic();},50);
    }
    updateColors(){
      this.colors={
        gridH:this.getStyle('--gridH'), gridV:this.getStyle('--gridV'), frame:this.getStyle('--frame'), label:this.getStyle('--label'),
        fft:this.getStyle('--fft'), peak:this.getStyle('--peak'), hold:this.getStyle('--hold'), bar:this.getStyle('--bar'),
        heat:[this.getStyle('--heatmap1'),this.getStyle('--heatmap2'),this.getStyle('--heatmap3'),this.getStyle('--heatmap4'),this.getStyle('--heatmap5')],
        db:{g:this.getStyle('--dbg'),y:this.getStyle('--dby'),o:this.getStyle('--dbo'),r:this.getStyle('--dbr')}
      };
    }

    /* ---------- DOM / events ---------- */
    bindUI(){
      const D=this.dom, S=this.state;

      // theme
      D.themeSelector.addEventListener('change',e=>this.applyTheme(e.target.value));

      // dock
      D.dockStart.addEventListener('click',()=>this.start());
      D.dockStop.addEventListener('click',()=>this.stop());
      D.dockHold.addEventListener('click',()=>{
        S.hold=!S.hold; D.dockHold.setAttribute('aria-pressed',S.hold);
      });
      D.dockClear.addEventListener('click',()=>this.clearPeaks());
      D.dockA.addEventListener('click',()=>{
        S.aweight=!S.aweight; D.dockA.setAttribute('aria-pressed',S.aweight);
      });

      // constraints toggle -> restart
      [D.ec,D.ns,D.agc].forEach(el=>el.addEventListener('change',()=>{
        if(S.running){ this.stop(); setTimeout(()=>this.start(),60); }
      }));

      // smoothing
      D.smoothing.addEventListener('input',()=>{ if(S.analyser) S.analyser.smoothingTimeConstant=parseFloat(D.smoothing.value); });

      // FFT size slider/preset sync
      D.fftPreset.addEventListener('change',(e)=>{
        const idx=this.FFT_SIZES.indexOf(parseInt(e.target.value,10)); D.fftSlider.value=idx; this.onConfigChange();
      });
      D.fftSlider.addEventListener('input',(e)=>{
        const idx=parseInt(e.target.value,10); D.fftPreset.value=this.FFT_SIZES[idx]; this.onConfigChange();
      });

      // Octave
      D.octRes.addEventListener('change',()=>{
        S.octN=parseInt(D.octRes.value,10); D.octResText.textContent={'3':'1/3','6':'1/6','12':'1/12'}[D.octRes.value]; S.bands=this.genBands(S.octN); S.peakOct=new Float32Array(S.bands.length);
      });
      D.octRange.addEventListener('input',()=>{S.octRangeMax=parseInt(D.octRange.value,10);});
      D.octRangePreset.addEventListener('change',()=>{S.octRangeMax=parseInt(D.octRangePreset.value,10); D.octRange.value=S.octRangeMax;});

      // Heatmap
      D.btnHeatOnOff.addEventListener('click',()=>{S.heatOn=!S.heatOn; D.btnHeatOnOff.textContent=S.heatOn?'ON':'OFF'; if(!S.heatOn){this.drawHeatOverlay();} });
      D.btnHeatHD.addEventListener('click',()=>{S.heatHD=!S.heatHD; D.btnHeatHD.setAttribute('aria-pressed',S.heatHD); S.heatBins=this.genHeatBins(); S.heatData=[]; if(S.heatOn) this.drawHeat(true); else this.drawHeatOverlay();});
      D.btnHeatClear.addEventListener('click',()=>{S.ath={v:-Infinity,i:0}; D.heatmapAth.textContent='ATH: ‚Äî';});
      D.heatPreset.addEventListener('change',()=>{S.heatRangeMax=parseInt(D.heatPreset.value,10); D.heatRange.value=S.heatRangeMax; D.heatRangeText.textContent=`-${S.heatRangeMax} dBFS`;});
      D.heatRange.addEventListener('input',()=>{S.heatRangeMax=parseInt(D.heatRange.value,10); D.heatRangeText.textContent=`-${S.heatRangeMax} dBFS`;});

      // guides
      this.attachPressGuide(D.fftCanvas,D.fftTip,(x,w)=>this.fmtHz(this.xToFreq(x,w)),(g)=>{this.state.guideFFT=g;});
      this.attachPressGuide(D.octCanvas,D.octTip,(x,w)=>this.fmtHz(this.xToFreq(x,w)),(g)=>{this.state.guideOCT=g;});
      this.attachPressGuide(D.heatCanvas,D.heatTip,(x,w)=>this.fmtHz(this.xToFreq(x,w)),(g)=>{this.state.guideSPEC=g;});

      // fullscreen buttons (‡∏£‡∏ß‡∏° logic ‡∏¢‡πâ‡∏≤‡∏¢‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏≠‡∏¢‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î)
      this.setupFsToggle(D.fsFFT, D.cardFFT);
      this.setupFsToggle(D.fsOCT, D.cardOCT);
      this.setupFsToggle(D.fsSPEC, D.cardSPEC);

      // resize/orientation/fullscreen change -> recalc
      window.addEventListener('resize',()=>this.handleResize());
      window.addEventListener('orientationchange',()=>setTimeout(()=>this.handleResize(),150));
      document.addEventListener('fullscreenchange',()=>this.handleResize());
    }

    setupCanvases(){
      this.canv = {
        fft:{canvas:this.dom.fftCanvas, ctx:this.dom.fftCanvas.getContext('2d')},
        oct:{canvas:this.dom.octCanvas, ctx:this.dom.octCanvas.getContext('2d')},
        heat:{canvas:this.dom.heatCanvas, ctx:this.dom.heatCanvas.getContext('2d')}
      };
      this.handleResize();
    }

    handleResize(){
      const dpr=window.devicePixelRatio||1;
      for(const key in this.canv){
        const c=this.canv[key].canvas, ctx=this.canv[key].ctx;
        const r=c.getBoundingClientRect();
        c.width=Math.max(1,Math.floor(r.width*dpr));
        c.height=Math.max(1,Math.floor(r.height*dpr));
        ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr);
      }
      this.drawAllStatic();
    }

    drawAllStatic(){
      this.drawBG(this.canv.fft.ctx);
      this.drawBG(this.canv.oct.ctx);
      this.drawHeatOverlay();
    }

    /* ---------- fullscreen & floating dock follow ---------- */
    moveDockTo(target){
      if(!this.floatDockEl) return;
      const dest = target || this.floatDockHome || document.body;
      if(this.floatDockEl.parentElement!==dest) dest.appendChild(this.floatDockEl);
    }
    setupFsToggle(btn, card){
      if(!btn || !card) return;
      const isActive = ()=> document.fullscreenElement===card || card.classList.contains('is-fullscreen');
      const icon = ()=> btn.textContent = isActive() ? 'üóó' : '‚õ∂';

      const enter = async ()=>{
        if(card.requestFullscreen){
          try{ await card.requestFullscreen({navigationUI:'hide'}); }catch{ card.classList.add('is-fullscreen'); }
        }else{ card.classList.add('is-fullscreen'); }
        this.moveDockTo(card); this.handleResize(); icon();
      };
      const exit = async ()=>{
        if(document.fullscreenElement===card && document.exitFullscreen){
          try{ await document.exitFullscreen(); }catch{ card.classList.remove('is-fullscreen'); }
        }else{ card.classList.remove('is-fullscreen'); }
        this.moveDockTo(this.floatDockHome); this.handleResize(); icon();
      };

      btn.addEventListener('click',()=>{ isActive()?exit():enter(); });
      document.addEventListener('fullscreenchange',()=>{
        const fs=document.fullscreenElement;
        if(fs===card) this.moveDockTo(card); else if(!fs) this.moveDockTo(this.floatDockHome);
        this.handleResize(); icon();
      });
      icon();
    }

    /* ---------- audio ---------- */
    async start(){
      const D=this.dom,S=this.state;
      D.dockStart.disabled=true;
      try{
        const constraints={audio:{
          echoCancellation:{ideal:D.ec.checked}, noiseSuppression:{ideal:D.ns.checked}, autoGainControl:{ideal:D.agc.checked}
        }};
        let stream;
        try{ stream=await navigator.mediaDevices.getUserMedia(constraints); }
        catch(e){ stream=await navigator.mediaDevices.getUserMedia({audio:true}); }

        const audioCtx=new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
        if(audioCtx.state==='suspended') await audioCtx.resume();
        const analyser=audioCtx.createAnalyser();
        const src=audioCtx.createMediaStreamSource(stream);
        src.connect(analyser);

        S.audioCtx=audioCtx; S.analyser=analyser; S.micSrc=src; S.stream=stream; S.running=true;
        this.onConfigChange();
        this.loop();

        D.dockStop.disabled=false;
      }catch(e){
        alert('‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏±‡∏î‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: '+(e.message||e));
        D.dockStart.disabled=false;
      }
    }
    stop(){
      const D=this.dom,S=this.state; if(!S.running) return; S.running=false;
      cancelAnimationFrame(S.rafId);
      try{ S.stream?.getTracks().forEach(t=>t.stop()); }catch(_){}
      try{ S.micSrc?.disconnect(); }catch(_){}
      try{ S.analyser?.disconnect(); }catch(_){}
      try{ S.audioCtx?.close(); }catch(_){}
      S.audioCtx=S.analyser=S.micSrc=S.stream=null;
      D.dockStart.disabled=false; D.dockStop.disabled=true;
    }
    onConfigChange(){
      const D=this.dom,S=this.state; if(!S.analyser) return;
      S.analyser.fftSize=parseInt(D.fftPreset.value,10);
      S.analyser.smoothingTimeConstant=parseFloat(D.smoothing.value);
      S.sampleRate=S.audioCtx.sampleRate;
      S.dataArray=new Uint8Array(S.analyser.fftSize);
      S.freqArray=new Uint8Array(S.analyser.frequencyBinCount);
      S.avgBuf=new Float32Array(S.analyser.frequencyBinCount);
      S.peakArray=new Uint8Array(S.analyser.frequencyBinCount);
      S.bands=this.genBands(S.octN);
      S.peakOct=new Float32Array(S.bands.length);
      S.heatBins=this.genHeatBins(); S.heatData=[]; S.ath={v:-Infinity,i:0};
    }

    loop(){
      const S=this.state; if(!S.running) return;
      S.analyser.getByteTimeDomainData(S.dataArray);
      S.analyser.getByteFrequencyData(S.freqArray);

      if(this.dom.avg.checked){
        const a=.5;
        for(let i=0;i<S.freqArray.length;i++){
          S.avgBuf[i]=a*S.avgBuf[i]+(1-a)*S.freqArray[i];
          S.freqArray[i]=S.avgBuf[i];
        }
      }

      this.drawFFT();
      this.drawOctave();
      if(S.heatOn){
        const now=performance.now();
        if(!this._lastHM || now-this._lastHM>33){ this.drawHeat(); this._lastHM=now; }
      }
      S.rafId=requestAnimationFrame(()=>this.loop());
    }

    /* ---------- draw common ---------- */
    drawBG(ctx){
      const w=ctx.canvas.clientWidth, h=ctx.canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      const plotH=h-this.PAD.T-this.PAD.B;
      ctx.strokeStyle=this.colors.gridH;
      for(let i=0;i<6;i++){
        const y=this.PAD.T+(i/5)*plotH; ctx.beginPath(); ctx.moveTo(this.PAD.L,y); ctx.lineTo(w-this.PAD.R,y); ctx.stroke();
      }
      ctx.strokeStyle=this.colors.gridV;
      const ticks=[20,31.5,40,50,63,80,100,125,160,200,250,315,400,500,630,800,1000,2000,4000,8000,16000];
      ticks.forEach(t=>{ const x=this.mapLogX(t,w); ctx.beginPath(); ctx.moveTo(x,this.PAD.T); ctx.lineTo(x,this.PAD.T+plotH); ctx.stroke(); });
      ctx.strokeStyle=this.colors.frame; ctx.strokeRect(this.PAD.L,this.PAD.T,w-this.PAD.L-this.PAD.R,plotH);
      ctx.fillStyle=this.colors.label; ctx.font='12px system-ui'; ctx.textBaseline='alphabetic';
      [31.5,63,125,250,500,1000,2000,4000,8000,16000].forEach(t=>{ const x=this.mapLogX(t,w); ctx.fillText(t>=1000?(t/1000)+'k':t,x-8,h-this.LABEL_Y); });
    }
    drawVLineWithLabel(ctx,x,w,h,color,dash,label){
      const y0=this.PAD.T,y1=h-this.PAD.B;
      ctx.save(); ctx.strokeStyle=color; ctx.lineWidth=1; if(dash) ctx.setLineDash([5,5]);
      ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke(); ctx.restore();
      if(!label) return;
      ctx.save(); ctx.font='12px system-ui'; const pad=6, boxH=18;
      const textW=ctx.measureText(label).width, boxW=textW+pad*2;
      let bx=Math.round(x-boxW/2); const minX=this.PAD.L+2, maxX=(w-this.PAD.R)-boxW-2;
      if(bx<minX) bx=minX; if(bx>maxX) bx=maxX;
      const by=y0+2;
      ctx.fillStyle='rgba(0,0,0,.55)'; ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.lineWidth=1;
      ctx.beginPath(); const r=8;
      ctx.moveTo(bx+r,by); ctx.lineTo(bx+boxW-r,by); ctx.quadraticCurveTo(bx+boxW,by,bx+boxW,by+r);
      ctx.lineTo(bx+boxW,by+boxH-r); ctx.quadraticCurveTo(bx+boxW,by+boxH,bx+boxW-r,by+boxH);
      ctx.lineTo(bx+r,by+boxH); ctx.quadraticCurveTo(bx,by+boxH,bx,by+boxH-r);
      ctx.lineTo(bx,by+r); ctx.quadraticCurveTo(bx,by,bx+r,by); ctx.closePath(); ctx.fill(); ctx.stroke();
      ctx.fillStyle=this.colors.label; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(label,bx+boxW/2,by+boxH/2+.5); ctx.restore();
    }

    /* ---------- FFT ---------- */
    drawFFT(){
      const ctx=this.canv.fft.ctx, w=ctx.canvas.clientWidth, h=ctx.canvas.clientHeight;
      this.drawBG(ctx);
      const S=this.state; if(!S.freqArray) return;
      const N=S.freqArray.length, fpb=S.sampleRate/(2*N);
      // trace
      ctx.beginPath(); let started=false;
      for(let i=1;i<N;i++){
        const f=i*fpb; if(f<20||f>this.fmax()) continue;
        let y=this.mapDbToY(this.dbfs(S.freqArray[i]),h); const x=this.mapLogX(f,w);
        if(!started){ctx.moveTo(x,y); started=true;} else ctx.lineTo(x,y);
      }
      ctx.strokeStyle=this.colors.fft; ctx.lineWidth=2; ctx.stroke();
      // hold trace
      if(this.state.hold){ for(let i=0;i<N;i++) S.peakArray[i]=Math.max(S.peakArray[i],S.freqArray[i]); }
      ctx.beginPath(); started=false;
      for(let i=1;i<N;i++){
        const f=i*fpb; if(f<20||f>this.fmax()) continue;
        let y=this.mapDbToY(this.dbfs(S.peakArray[i]||0),h); const x=this.mapLogX(f,w);
        if(!started){ctx.moveTo(x,y); started=true;} else ctx.lineTo(x,y);
      }
      ctx.save(); ctx.globalAlpha=.35; ctx.strokeStyle=this.colors.peak; ctx.lineWidth=1.25; ctx.stroke(); ctx.restore();

      // peak now + hold line
      let pbin=0,pval=-Infinity; for(let i=0;i<N;i++) if(S.freqArray[i]>pval){pval=S.freqArray[i]; pbin=i;}
      const pf=pbin*fpb; this.dom.fftPeakText.textContent=`Peak: ${this.fmtHz(pf)}`;
      let hbin=0,hv=0; for(let i=0;i<N;i++) if(S.peakArray[i]>hv){hv=S.peakArray[i]; hbin=i;}
      if(hv>0){
        this.dom.fftHoldText.style.display='';
        const hz=this.fmtHz(hbin*fpb); this.dom.fftHoldText.textContent=`Hold: ${hz}`;
        this.drawVLineWithLabel(ctx,this.mapLogX(hbin*fpb,w),w,h,this.colors.hold,true,hz);
      }else this.dom.fftHoldText.style.display='none';
      this.drawVLineWithLabel(ctx,this.mapLogX(pf,w),w,h,'rgba(100,149,237,.6)',false,null);

      if(this.state.guideFFT) this.drawGuide(ctx,this.state.guideFFT.x,h);
    }
    drawGuide(ctx,x,h){
      ctx.save(); ctx.strokeStyle='rgba(100,149,237,.75)'; ctx.setLineDash([4,4]);
      ctx.beginPath(); ctx.moveTo(x,this.PAD.T); ctx.lineTo(x,h-this.PAD.B); ctx.stroke(); ctx.restore();
    }

    /* ---------- Octave ---------- */
    genBands(n){
      const r=Math.pow(2,1/n), fm=this.fmax(), fmin=20;
      const kmin=Math.ceil(Math.log(fmin/1000)/Math.log(r));
      const kmax=Math.floor(Math.log(fm/1000)/Math.log(r));
      const edge=Math.pow(2,1/(2*n));
      const arr=[];
      for(let k=kmin;k<=kmax;k++){
        const fc=1000*Math.pow(r,k), fl=fc/edge, fh=fc*edge;
        if(fh<fmin||fl>fm) continue;
        arr.push({fc, fl:Math.max(fl,fmin), fh:Math.min(fh,fm)});
      }
      return arr;
    }
    drawOctave(){
      const ctx=this.canv.oct.ctx, w=ctx.canvas.clientWidth, h=ctx.canvas.clientHeight;
      this.drawBG(ctx);
      const S=this.state; if(!S.freqArray||!S.bands.length) return;
      const N=S.freqArray.length, fpb=S.sampleRate/(2*N);
      const vals=S.bands.map(b=>{
        const s=Math.max(0,Math.floor(b.fl/fpb)), e=Math.min(N-1,Math.ceil(b.fh/fpb));
        let sum=0,cnt=0; for(let i=s;i<=e;i++){sum+=S.freqArray[i]; cnt++;}
        let v=cnt?(sum/cnt):0; if(S.aweight) v*=Math.pow(10,this.aWeighting(b.fc)/20); return v;
      });
      if(S.hold){ for(let i=0;i<vals.length;i++) S.peakOct[i]=Math.max(S.peakOct[i],vals[i]); }
      // bars
      ctx.fillStyle=this.colors.bar;
      for(let i=0;i<vals.length;i++){
        const b=S.bands[i], xL=this.mapLogX(b.fl,w), xR=this.mapLogX(b.fh,w);
        const y=this.mapLinearToYOct(vals[i],h), barW=Math.max(2,xR-xL-2), barH=(h-this.PAD.B-y);
        ctx.fillRect(xL+1,y,barW,Math.max(1,barH));
      }
      // hold line
      ctx.beginPath();
      for(let i=0;i<vals.length;i++){
        const cx=this.mapLogX(S.bands[i].fc,w); const y=this.mapLinearToYOct(S.peakOct[i]||0,h);
        if(i===0) ctx.moveTo(cx,y); else ctx.lineTo(cx,y);
      }
      ctx.save(); ctx.globalAlpha=.45; ctx.strokeStyle=this.colors.hold; ctx.lineWidth=1.5; ctx.stroke(); ctx.restore();

      // peaks
      let iNow=0,vNow=-1; for(let i=0;i<vals.length;i++) if(vals[i]>vNow){vNow=vals[i]; iNow=i;}
      let iHold=0,vHold=0; for(let i=0;i<S.peakOct.length;i++) if(S.peakOct[i]>vHold){vHold=S.peakOct[i]; iHold=i;}
      this.dom.octPeakText.textContent=`Peak: ${this.fmtHz(S.bands[iNow].fc)}`;
      if(vHold>0){
        this.dom.octHoldText.style.display='';
        const hz=this.fmtHz(S.bands[iHold].fc); this.dom.octHoldText.textContent=`Hold: ${hz}`;
        this.drawVLineWithLabel(ctx,this.mapLogX(S.bands[iHold].fc,w),w,h,this.colors.hold,true,hz);
      }else this.dom.octHoldText.style.display='none';
      this.drawVLineWithLabel(ctx,this.mapLogX(S.bands[iNow].fc,w),w,h,'rgba(100,149,237,.6)',false,null);

      if(this.state.guideOCT) this.drawGuide(ctx,this.state.guideOCT.x,h);
    }

    /* ---------- Spectrogram ---------- */
    genHeatBins(){
      if(!this.state.analyser) return null;
      const num=this.state.heatHD?this.HEAT_HD:this.HEAT_SD;
      const fm=this.fmax(), fpb=this.state.sampleRate/this.state.analyser.fftSize, fmin=20;
      const logFmin=Math.log10(fmin), logFmax=Math.log10(fm);
      const bins=[];
      for(let i=0;i<num;i++){
        const logFs=logFmin+(i/num)*(logFmax-logFmin);
        const logFe=logFmin+((i+1)/num)*(logFmax-logFmin);
        const fStart=10**logFs, fEnd=10**logFe;
        const s=Math.max(0,Math.floor(fStart/fpb)), e=Math.min(this.state.analyser.frequencyBinCount-1,Math.ceil(fEnd/fpb));
        bins.push({s,e, fStart, fEnd});
      }
      return bins;
    }
    heatColor(db){ // map to theme colors by range
      const max=0, min=max-this.state.heatRangeMax;
      const t=this.clamp01((db-min)/(max-min));
      if(t<.25) return this.colors.heat[0];
      if(t<.5)  return this.colors.heat[1];
      if(t<.75) return this.colors.heat[2];
      if(t<.9)  return this.colors.heat[3];
      return this.colors.heat[4];
    }
    drawHeatOverlay(){
      const ctx=this.canv.heat.ctx, w=ctx.canvas.clientWidth, h=ctx.canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle='rgba(255,255,255,.4)'; ctx.font='24px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('Heatmap OFF', w/2, (h-this.PAD.B)/2);
      // grid/footer
      const plotH=h-this.PAD.B;
      ctx.strokeStyle=this.colors.frame; ctx.strokeRect(this.PAD.L,0,w-this.PAD.L-this.PAD.R,plotH);
      ctx.strokeStyle=this.colors.gridV;
      const ticks=[20, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000, 2000, 4000, 8000, 16000];
      ticks.forEach(t=>{ const x=this.mapLogX(t,w); ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,plotH); ctx.stroke(); });
      ctx.fillStyle=this.colors.label; ctx.font='12px system-ui'; ctx.textBaseline='alphabetic';
      [31.5,63,125,250,500,1000,2000,4000,8000,16000].forEach(t=>{ const x=this.mapLogX(t,w); ctx.fillText(t>=1000?(t/1000)+'k':t,x-8,h-this.LABEL_Y); });
    }
    drawHeat(force=false){
      const ctx=this.canv.heat.ctx, w=ctx.canvas.clientWidth, h=ctx.canvas.clientHeight;
      const plotH=h-this.PAD.B;
      const S=this.state; if(!S.freqArray || !S.heatBins) return;

      // make row
      const row=S.heatBins.map(b=>{
        let sum=0,cnt=0; for(let i=b.s;i<=b.e;i++){sum+=S.freqArray[i];cnt++;}
        const db=cnt>0?this.dbfs(sum/cnt):-100; return {db};
      });

      // ATH tracking
      let peakI=0,peakV=-Infinity; for(let i=0;i<row.length;i++){ if(row[i].db>peakV){peakV=row[i].db; peakI=i;} }
      if(peakV>S.ath.v){ S.ath={v:peakV,i:peakI}; }
      const athBin=S.heatBins[S.ath.i]; if(athBin){ const f=(athBin.fStart+athBin.fEnd)/2; this.dom.heatmapAth.textContent=`ATH: ${this.fmtHz(f)}`; }

      // push & trim
      S.heatData.unshift(row); if(S.heatData.length>this.HEAT_T) S.heatData.pop();

      // draw
      ctx.clearRect(0,0,w,h);
      const yScale=plotH/this.HEAT_T;
      for(let t=0;t<S.heatData.length;t++){
        const y=t*yScale; const r=S.heatData[t];
        for(let i=0;i<r.length;i++){
          const bin=S.heatBins[i]; const xL=this.mapLogX(bin.fStart,w), xR=this.mapLogX(bin.fEnd,w);
          ctx.fillStyle=this.heatColor(r[i].db);
          ctx.fillRect(xL,y,Math.max(1,xR-xL),yScale+0.5);
        }
      }
      // grid & labels
      ctx.strokeStyle=this.colors.frame; ctx.strokeRect(this.PAD.L,0,w-this.PAD.L-this.PAD.R,plotH);
      ctx.strokeStyle=this.colors.gridV;
      const ticks=[20, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000, 2000, 4000, 8000, 16000];
      ticks.forEach(t=>{ const x=this.mapLogX(t,w); ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,plotH); ctx.stroke(); });
      ctx.fillStyle=this.colors.label; ctx.font='12px system-ui'; ctx.textBaseline='alphabetic';
      [31.5,63,125,250,500,1000,2000,4000,8000,16000].forEach(t=>{ const x=this.mapLogX(t,w); ctx.fillText(t>=1000?(t/1000)+'k':t,x-8,h-this.LABEL_Y); });

      if(this.state.guideSPEC){
        ctx.save(); ctx.strokeStyle='rgba(100,149,237,.75)'; ctx.setLineDash([4,4]);
        ctx.beginPath(); ctx.moveTo(this.state.guideSPEC.x,0); ctx.lineTo(this.state.guideSPEC.x,plotH); ctx.stroke(); ctx.restore();
      }
    }

    /* ---------- helpers ---------- */
    attachPressGuide(canvas, tipEl, fmt, setter){
      let pressed=false;
      const getX=(e)=>{ const r=canvas.getBoundingClientRect(); const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left; return Math.max(this.PAD.L,Math.min(r.width-this.PAD.R,x)); };
      const update=(xPx)=>{ const freq=this.xToFreq(xPx, canvas.getBoundingClientRect().width); tipEl.style.display='block'; tipEl.textContent=fmt(xPx,canvas.getBoundingClientRect().width) || this.fmtHz(freq); tipEl.style.left=xPx+'px'; tipEl.style.top='8px'; setter({x:xPx, freq}); };
      const clear=()=>{pressed=false; tipEl.style.display='none'; setter(null);};
      const down=(e)=>{pressed=true; e.preventDefault(); update(getX(e));};
      const move=(e)=>{if(!pressed) return; e.preventDefault(); update(getX(e));};
      const up=()=>clear();
      canvas.addEventListener('mousedown',down); canvas.addEventListener('mousemove',move);
      canvas.addEventListener('mouseup',up); canvas.addEventListener('mouseleave',up);
      canvas.addEventListener('touchstart',down,{passive:false}); canvas.addEventListener('touchmove',move,{passive:false}); canvas.addEventListener('touchend',up);
    }

    clearPeaks(){ this.state.peakArray?.fill(0); this.state.peakOct?.fill(0); }

    /* ---------- start ---------- */
  }

  /* instantiate */
  const app=new RTAnalyzer();
})();
</script>
</body>
</html>

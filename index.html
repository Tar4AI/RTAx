<!DOCTYPE html>
<html lang="th" data-theme="studio-blue">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0F172A" />
  <title>my RTAs (v1.5)</title>
  <style>
    /* ==== Themes ========================================================= */
    :root, [data-theme="studio-blue"]{
      --bg1:#0F172A; --bg2:#1E293B; --card:#1E293B; --text:#E2E8F0; --muted:#64748B;
      --gridH:rgba(255,255,255,.10); --gridV:rgba(255,255,255,.05);
      --frame:rgba(255,255,255,.12); --label:rgba(255,255,255,.85);
      --fft:#22D3EE; --peak:#A5B4FC; --hold:#F472B6; --bar:#22D3EE;
      --heatmap1:#0F172A; --heatmap2:#334155; --heatmap3:#0EA5E9; --heatmap4:#A78BFA; --heatmap5:#F472B6;
      --dbGreen:#22D3EE; --dbYellow:#A78BFA; --dbOrange:#EC4899; --dbRed:#F43F5E;
      --accent:#60A5FA;
    }
    [data-theme="dark-matter"]{
      --bg1:#1a202c; --bg2:#1a202c; --card:#2d3748; --text:#cbd5e1; --muted:#718096;
      --gridH:rgba(255,255,255,.08); --gridV:rgba(255,255,255,.04);
      --frame:rgba(255,255,255,.1); --label:rgba(255,255,255,.85);
      --fft:#68d391; --peak:#b794f4; --hold:#f6ad55; --bar:#68d391;
      --heatmap1:#1a202c; --heatmap2:#4a5568; --heatmap3:#68d391; --heatmap4:#f6ad55; --heatmap5:#e53e3e;
      --dbGreen:#48bb78; --dbYellow:#f6ad55; --dbOrange:#ed8936; --dbRed:#e53e3e;
      --accent:#2DD4BF;
    }
    [data-theme="vintage-amber"]{
      --bg1:#292524; --bg2:#1c1917; --card:#44403C; --text:#D6D3D1; --muted:#A8A29E;
      --gridH:rgba(255,250,235,.10); --gridV:rgba(255,250,235,.05);
      --frame:rgba(255,250,235,.12); --label:rgba(255,255,255,.9);
      --fft:#F59E0B; --peak:#FDE68A; --hold:#FDBA74; --bar:#F59E0B;
      --heatmap1:#292524; --heatmap2:#78716C; --heatmap3:#F59E0B; --heatmap4:#FBBF24; --heatmap5:#EF4444;
      --dbGreen:#F59E0B; --dbYellow:#FACC15; --dbOrange:#FB923C; --dbRed:#EF4444;
      --accent:#D97706;
    }

    :root{ color-scheme:dark }
    html{ background:var(--bg1) }
    body{
      margin:0; background:radial-gradient(1200px 600px at 70% -10%, var(--card) 10%, var(--bg1) 60%, var(--bg2) 100%);
      color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans Thai",sans-serif;
      -webkit-touch-callout:none; -webkit-user-select:none; user-select:none; overscroll-behavior:contain;
    }
    /* safe-area notches */
    body::before,body::after{content:"";position:fixed;left:0;right:0;z-index:999;background:var(--bg1);pointer-events:none}
    body::before{top:0;height:env(safe-area-inset-top)} body::after{bottom:0;height:env(safe-area-inset-bottom)}

    .wrap{max-width:1100px;margin:0 auto;padding:16px 12px; display:flex; flex-direction:column; gap:12px}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .card{background:var(--card);border:1px solid rgba(255,255,255,.1);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:12px;}
    label{font-size:12px;color:var(--muted)}
    select,input[type=range],input[type=number]{accent-color:var(--accent)}
    canvas{width:100%;height:320px;background:var(--bg1);border-radius:12px;display:block}

    .plot{position:relative;height:320px;margin-top:8px}
    .tip{position:absolute;padding:4px 6px;font-size:12px;color:#e5e7eb;background:rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.12);border-radius:8px;transform:translate(-50%,-100%);white-space:nowrap;pointer-events:none;z-index:5;display:none}
    .badge{padding:4px 8px;border-radius:999px;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);font-size:12px;color:#e5e7eb;white-space:nowrap}

    .section-head{display:flex;justify-content:space-between;align-items:center}
    .right-tools{display:flex;gap:8px;align-items:center}
    .icon-btn{background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:6px;cursor:pointer;color:var(--text)}
    .icon-btn:hover{background:rgba(255,255,255,.08)}
    .icon{font-size:16px;line-height:16px;display:inline-block;transform:translateY(1px)}

    /* ---- Floating dock -------------------------------------------------- */
    .float-dock{
      position:fixed; left:12px; top:50%; transform:translateY(-50%);
      display:flex; flex-direction:column; gap:10px; z-index:10000;
    }
    .float-dock .fbtn{
      width:36px; height:36px; border-radius:10px; display:grid; place-items:center;
      background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.15); color:var(--text);
      box-shadow:0 8px 20px rgba(0,0,0,.35); cursor:pointer;
    }
    .float-dock .fbtn:active{transform:scale(.98)}
    .fbtn[aria-pressed="true"]{outline:2px solid var(--accent); outline-offset:0}

    /* in-fullscreen tweak (same fixed viewport, but we keep in case spacing needed) */
    .float-dock.in-fs{left:12px}

    /* ---- Pseudo fullscreen (mobile fallback) --------------------------- */
    .ps-fs{
      position:fixed !important; inset: env(safe-area-inset-top) 0 env(safe-area-inset-bottom) 0;
      z-index:9990; margin:0 !important; border-radius:0 !important;
      width:100vw; height:calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      overflow:hidden;
    }

    /* small mobiles: raise canvas height a bit */
    @media (max-width: 480px){
      canvas{height:360px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="row" style="justify-content:space-between;align-items:center;">
        <h2 style="margin:0">my RTAs (v1.5)</h2>
        <label>Theme
          <select id="themeSel">
            <option value="studio-blue" selected>Studio Blue</option>
            <option value="dark-matter">Dark Matter</option>
            <option value="vintage-amber">Vintage Amber</option>
          </select>
        </label>
      </div>
      <div class="row" style="margin-top:6px">
        <label> Smoothing
          <input id="smoothing" type="range" min="0" max="0.95" step="0.01" value="0.75">
        </label>
        <label> Averaging
          <input id="avg" type="checkbox" checked>
        </label>
        <div class="row" style="margin-left:auto">
          <label>FFT Size
            <input id="fftSlider" type="range" min="0" max="3" step="1" value="1">
            <select id="fftSel">
              <option value="2048">2048</option>
              <option value="4096" selected>4096</option>
              <option value="8192">8192</option>
              <option value="16384">16384</option>
            </select>
          </label>
        </div>
      </div>
    </div>

    <!-- ================= FFT ========================================== -->
    <div id="cardFFT" class="card">
      <div class="section-head">
        <div class="row" style="gap:8px;align-items:center">
          <b>RTA FFT - Log</b>
          <span class="badge" id="fftNow">Peak: —</span>
          <span class="badge" id="fftHold" style="display:none">Hold: —</span>
        </div>
        <div class="right-tools">
          <button class="icon-btn" id="btnFsFFT" title="ขยาย/ย่อ"><span class="icon">⤢</span></button>
        </div>
      </div>
      <div class="plot">
        <canvas id="fftCanvas"></canvas>
        <div id="fftTip" class="tip">—</div>
      </div>
    </div>

    <!-- ================= Octave ======================================= -->
    <div id="cardOCT" class="card">
      <div class="section-head">
        <div class="row" style="gap:8px;align-items:center">
          <b>RTA</b>
          <select id="octRes">
            <option value="3">1/3</option>
            <option value="6">1/6</option>
            <option value="12" selected>1/12</option>
          </select>
          <b>Octave</b>
          <span class="badge" id="octNow">Peak: —</span>
          <span class="badge" id="octHold" style="display:none">Hold: —</span>
          <div class="row" style="margin-left:12px">
            <label style="display:flex;align-items:center;gap:6px">Range
              <input id="octRange" type="range" min="64" max="1023" step="1" value="255">
              <select id="octRangePreset">
                <option value="127">127</option>
                <option value="255" selected>256</option>
                <option value="511">512</option>
              </select>
            </label>
          </div>
        </div>
        <div class="right-tools">
          <button class="icon-btn" id="btnFsOCT" title="ขยาย/ย่อ"><span class="icon">⤢</span></button>
        </div>
      </div>
      <div class="plot">
        <canvas id="octCanvas"></canvas>
        <div id="octTip" class="tip">—</div>
      </div>
    </div>

    <!-- ================= Spectrogram ================================== -->
    <div id="cardSPEC" class="card">
      <div class="section-head">
        <div class="row" style="gap:8px;align-items:center">
          <b>Spectrogram</b>
          <span class="badge" id="athText">ATH: —</span>
          <div class="row" style="margin-left:12px">
            <label style="display:flex;align-items:center;gap:6px">Range
              <input id="hmRange" type="range" min="5" max="100" step="5" value="50">
              <select id="hmRangePreset">
                <option value="5">5</option><option value="10">10</option><option value="20">20</option>
                <option value="40">40</option><option value="50" selected>50</option>
                <option value="60">60</option><option value="80">80</option><option value="100">100</option>
              </select>
            </label>
            <span class="badge" id="hmRangeText">-50 dBFS</span>
          </div>
        </div>
        <div class="right-tools">
          <button class="icon-btn" id="btnFsSPEC" title="ขยาย/ย่อ"><span class="icon">⤢</span></button>
        </div>
      </div>
      <div class="plot">
        <canvas id="hmCanvas"></canvas>
        <div id="hmTip" class="tip">—</div>
      </div>
    </div>
  </div>

  <!-- ======= Floating dock (หลัก: ▶️, ⏸️, 📌, ♻️, 👂) ================== -->
  <div id="floatDock" class="float-dock" aria-label="Controls">
    <button id="fStart" class="fbtn" title="เริ่ม"><span>▶️</span></button>
    <button id="fStop"  class="fbtn" title="หยุด" disabled><span>⏸️</span></button>
    <button id="fHold"  class="fbtn" title="Hold Peak" aria-pressed="true"><span>📌</span></button>
    <button id="fClear" class="fbtn" title="Clear Peak"><span>♻️</span></button>
    <button id="fAwt"  class="fbtn" title="A-weighting" aria-pressed="false"><span>👂</span></button>
  </div>

  <script>
  (() => {
    /* =================== Small utilities =================== */
    const $$ = sel => document.querySelector(sel);
    const map = (x,in0,in1,out0,out1)=> out0 + (out1-out0) * ((x-in0)/(in1-in0));
    const clamp01 = v => Math.min(1, Math.max(0, v));

    /* =================== Analyzer core ===================== */
    const FFT_SIZES = [2048,4096,8192,16384];
    const PAD = {L:40,R:10,T:10,B:32};

    const el = {
      themeSel: $('#themeSel'),
      smoothing: $('#smoothing'),
      avg: $('#avg'),
      fftSlider: $('#fftSlider'),
      fftSel: $('#fftSel'),

      cardFFT: $('#cardFFT'), fftCanvas: $('#fftCanvas'), fftTip: $('#fftTip'),
      cardOCT: $('#cardOCT'), octCanvas: $('#octCanvas'), octTip: $('#octTip'),
      cardSPEC: $('#cardSPEC'), hmCanvas: $('#hmCanvas'), hmTip: $('#hmTip'),

      btnFsFFT: $('#btnFsFFT'), btnFsOCT: $('#btnFsOCT'), btnFsSPEC: $('#btnFsSPEC'),

      fftNow: $('#fftNow'), fftHold: $('#fftHold'),
      octNow: $('#octNow'), octHold: $('#octHold'),

      octRes: $('#octRes'), octRange: $('#octRange'), octRangePreset: $('#octRangePreset'),

      hmRange: $('#hmRange'), hmRangePreset: $('#hmRangePreset'), hmRangeText: $('#hmRangeText'),
      athText: $('#athText'),

      // floating dock
      dock: $('#floatDock'),
      fStart: $('#fStart'), fStop: $('#fStop'), fHold: $('#fHold'), fClear: $('#fClear'), fAwt: $('#fAwt'),
    };

    // theme
    el.themeSel.addEventListener('change', e => { document.documentElement.dataset.theme = e.target.value; drawFrames(); });

    // audio state
    const st = {
      ctx:null, an:null, src:null, stream:null,
      dataTD:null, dataF:null, avgBuf:null, peakF:null,
      holdEnabled:true, aWeight:false,
      running:false,
      bands:[], peakOct:null, octN:12,
      sampleRate:48000,
      hmBins:[], hmData:[], hmRangeMax:50, ath:{val:-Infinity, bin:0},
    };

    /* ---------- setup canvases ---------- */
    const cvs = {
      fft: {c: el.fftCanvas, tip: el.fftTip}, oct:{c: el.octCanvas, tip: el.octTip}, hm:{c: el.hmCanvas, tip: el.hmTip}
    };
    const getStyle = p => getComputedStyle(document.documentElement).getPropertyValue(p).trim();
    const colors = () => ({
      gridH:getStyle('--gridH'), gridV:getStyle('--gridV'),
      frame:getStyle('--frame'), label:getStyle('--label'),
      fft:getStyle('--fft'), peak:getStyle('--peak'), hold:getStyle('--hold'), bar:getStyle('--bar'),
      heatmap:[getStyle('--heatmap1'),getStyle('--heatmap2'),getStyle('--heatmap3'),getStyle('--heatmap4'),getStyle('--heatmap5')]
    });

    function resizeAll(){
      const dpr = devicePixelRatio || 1;
      for(const k of Object.keys(cvs)){
        const c = cvs[k].c; const rect = c.getBoundingClientRect();
        c.width = rect.width * dpr; c.height = rect.height * dpr;
        const ctx = c.getContext('2d'); ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr);
      }
      drawFrames();
      if (st.running){ drawFFT(); drawOct(); drawHM(true); }
    }
    addEventListener('resize', resizeAll);

    /* ---------- map & format ---------- */
    const fmax = ()=> Math.min(st.sampleRate/2, 20000);
    const fmtHz = f => f>=1000 ? ((f/1000>=10?(f/1000).toFixed(0):(f/1000).toFixed(1)) + ' kHz') : (Math.round(f)+' Hz');
    const dbfs = v => 20*Math.log10(v/255 + 1e-12);
    const aWeighting = f => { const f2=f*f; const ra = (12200**2 * f2**2)/((f2+20.6**2)*(f2+12200**2)*Math.sqrt((f2+107.7**2)*(f2+737.9**2))); return 20*Math.log10(ra)+2.0; };
    const mapLogX = (f,w)=>{ const fm=fmax(), fmin=20; const t=(Math.log10(Math.max(f,fmin))-Math.log10(fmin))/(Math.log10(fm)-Math.log10(fmin)); return PAD.L + t*(w-PAD.L-PAD.R); };
    const xToFreq = (x,w)=>{ const fm=fmax(), fmin=20; const plotW=w-PAD.L-PAD.R; const t=clamp01((x-PAD.L)/plotW); const lf=Math.log10(fmin)+t*(Math.log10(fm)-Math.log10(fmin)); return 10**lf; };
    const mapDbToY = (db,h)=>{ const norm=clamp01((db+100)/100); const plotH=h-PAD.T-PAD.B; return PAD.T + (1-norm)*plotH; };
    const mapOctToY = (v,h,max=255)=>{ const norm=clamp01(v/Math.max(1,max)); const plotH=h-PAD.T-PAD.B; return PAD.T + (1-norm)*plotH; };

    /* ---------- draw frames ---------- */
    function drawBG(ctx){
      const W=ctx.canvas.getBoundingClientRect().width, H=ctx.canvas.getBoundingClientRect().height;
      ctx.clearRect(0,0,W,H);
      const plotH = H-PAD.T-PAD.B;
      ctx.strokeStyle = colors().gridH;
      for(let i=0;i<6;i++){ const y=PAD.T + (i/5)*plotH; ctx.beginPath(); ctx.moveTo(PAD.L,y); ctx.lineTo(W-PAD.R,y); ctx.stroke(); }
      ctx.strokeStyle = colors().gridV;
      [20,31.5,40,50,63,80,100,125,160,200,250,315,400,500,630,800,1000,2000,4000,8000,16000].forEach(t=>{ const x=mapLogX(t,W); ctx.beginPath(); ctx.moveTo(x,PAD.T); ctx.lineTo(x,PAD.T+plotH); ctx.stroke(); });
      ctx.strokeStyle = colors().frame; ctx.strokeRect(PAD.L,PAD.T,W-PAD.L-PAD.R,plotH);
      ctx.fillStyle = colors().label; ctx.font = '12px system-ui'; ctx.textBaseline='alphabetic';
      [31.5,63,125,250,500,1000,2000,4000,8000,16000].forEach(t=>{ const x=mapLogX(t,W); ctx.fillText(t>=1000?(t/1000)+'k':t, x-8, H-10); });
    }
    function drawFrames(){ drawBG(cvs.fft.c.getContext('2d')); drawBG(cvs.oct.c.getContext('2d')); const ctx=cvs.hm.c.getContext('2d'); ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height); }

    /* ---------- bands & bins ---------- */
    function genBands(n){
      const r=2**(1/n), fm=fmax(), fmin=20, kmin=Math.ceil(Math.log(fmin/1000)/Math.log(r)), kmax=Math.floor(Math.log(fm/1000)/Math.log(r)), eh=2**(1/(2*n));
      const arr=[]; for(let k=kmin;k<=kmax;k++){ const fc=1000*r**k, fl=fc/eh, fh=fc*eh; if (fh<fmin||fl>fm) continue; arr.push({fc, fl:Math.max(fl,fmin), fh:Math.min(fh,fm)}); } return arr;
    }
    function genHmBins(num=300){
      if (!st.an) return [];
      const fm=fmax(), fpb=st.sampleRate/st.an.fftSize, fmin=20, logFmin=Math.log10(fmin), logFmax=Math.log10(fm), bins=[];
      for(let i=0;i<num;i++){
        const lfs=logFmin + (i/num)*(logFmax-logFmin), lfe=logFmin + ((i+1)/num)*(logFmax-logFmin);
        const fStart=10**lfs, fEnd=10**lfe;
        const b0=Math.max(0,Math.floor(fStart/fpb)), b1=Math.min(st.an.frequencyBinCount-1,Math.ceil(fEnd/fpb));
        bins.push({b0,b1,fStart,fEnd});
      }
      return bins;
    }

    /* =================== Audio start/stop =================== */
    async function start(){
      el.fStart.disabled = true;
      try{
        const stream = await navigator.mediaDevices.getUserMedia({audio:true});
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const an = ctx.createAnalyser();
        const src = ctx.createMediaStreamSource(stream);
        src.connect(an);
        st.ctx=ctx; st.an=an; st.src=src; st.stream=stream; st.running=true;

        onConfig();
        loop();
        el.fStop.disabled=false;
      }catch(e){
        alert('เริ่มไม่ได้: ' + (e.message||e));
        el.fStart.disabled=false;
      }
    }
    function stop(){
      if (!st.running) return;
      st.running=false;
      cancelAnimationFrame(st.raf);
      try{ st.stream?.getTracks().forEach(t=>t.stop()); }catch(_){}
      try{ st.src?.disconnect(); st.an?.disconnect(); st.ctx?.close(); }catch(_){}
      st.ctx=st.an=st.src=st.stream=null;
      el.fStart.disabled=false; el.fStop.disabled=true;
    }

    /* =================== Config ============================ */
    function onConfig(){
      if (!st.an) return;
      st.an.fftSize = parseInt(el.fftSel.value,10);
      st.an.smoothingTimeConstant = parseFloat(el.smoothing.value);
      st.dataTD = new Uint8Array(st.an.fftSize);
      st.dataF  = new Uint8Array(st.an.frequencyBinCount);
      st.avgBuf = new Float32Array(st.an.frequencyBinCount);
      st.peakF  = new Uint8Array(st.an.frequencyBinCount);
      st.sampleRate = st.ctx.sampleRate;

      st.octN = parseInt(el.octRes.value,10);
      st.bands = genBands(st.octN);
      st.peakOct = new Float32Array(st.bands.length);

      st.hmBins = genHmBins(300);
      st.hmData = []; st.ath = {val:-Infinity, bin:0};
    }

    // link sliders & selects
    el.fftSel.addEventListener('change', e=>{
      el.fftSlider.value = FFT_SIZES.indexOf(parseInt(e.target.value,10));
      onConfig();
    });
    el.fftSlider.addEventListener('input', e=>{
      const idx = parseInt(e.target.value,10); el.fftSel.value = FFT_SIZES[idx]; onConfig();
    });
    el.smoothing.addEventListener('input', ()=>{ if(st.an) st.an.smoothingTimeConstant=parseFloat(el.smoothing.value); });
    el.avg.addEventListener('change', ()=>{});
    el.octRes.addEventListener('change', ()=>onConfig());
    el.octRangePreset.addEventListener('change', e=>{ el.octRange.value = e.target.value; });

    el.hmRange.addEventListener('input', ()=>{ st.hmRangeMax = parseInt(el.hmRange.value,10); el.hmRangeText.textContent = `-${st.hmRangeMax} dBFS`; });
    el.hmRangePreset.addEventListener('change', e=>{ el.hmRange.value=e.target.value; st.hmRangeMax=parseInt(e.target.value,10); el.hmRangeText.textContent = `-${st.hmRangeMax} dBFS`; });

    /* =================== Drawing =========================== */
    function drawFFT(){
      const ctx = cvs.fft.c.getContext('2d'); const W=ctx.canvas.getBoundingClientRect().width, H=ctx.canvas.getBoundingClientRect().height;
      drawBG(ctx);

      if (!st.dataF) return;
      const N=st.dataF.length, fpb=st.sampleRate/(2*N);

      if (el.avg.checked){
        const a=0.5;
        for (let i=0;i<N;i++){ st.avgBuf[i] = a*st.avgBuf[i] + (1-a)*st.dataF[i]; st.dataF[i] = st.avgBuf[i]; }
      }
      if (st.holdEnabled) for(let i=0;i<N;i++) st.peakF[i] = Math.max(st.peakF[i], st.dataF[i]);

      ctx.beginPath(); let started=false;
      for(let i=1;i<N;i++){
        const f=i*fpb; if (f<20||f>fmax()) continue;
        const x=mapLogX(f,W), y=mapDbToY(dbfs(st.dataF[i]),H);
        if (!started){ctx.moveTo(x,y); started=true;} else ctx.lineTo(x,y);
      }
      ctx.strokeStyle=colors().fft; ctx.lineWidth=2; ctx.stroke();

      ctx.beginPath(); started=false;
      for(let i=1;i<N;i++){
        const f=i*fpb; if (f<20||f>fmax()) continue;
        const x=mapLogX(f,W), y=mapDbToY(dbfs(st.peakF[i]||0),H);
        if (!started){ctx.moveTo(x,y); started=true;} else ctx.lineTo(x,y);
      }
      ctx.save(); ctx.globalAlpha=.35; ctx.strokeStyle=colors().peak; ctx.lineWidth=1.25; ctx.stroke(); ctx.restore();

      // labels & guides
      let peakBin=0, peakVal=-Infinity; for(let i=0;i<N;i++) if (st.dataF[i]>peakVal){peakVal=st.dataF[i]; peakBin=i;}
      const peakHz = peakBin*fpb; el.fftNow.textContent = `Peak: ${fmtHz(peakHz)}`;

      let holdBin=0, holdVal=0; for(let i=0;i<N;i++) if (st.peakF[i]>holdVal){holdVal=st.peakF[i]; holdBin=i;}
      if (holdVal>0){ el.fftHold.style.display=''; el.fftHold.textContent=`Hold: ${fmtHz(holdBin*fpb)}`; drawVLine(ctx, mapLogX(holdBin*fpb,W), H, colors().hold, true, fmtHz(holdBin*fpb)); }
      else el.fftHold.style.display='none';

      drawVLine(ctx, mapLogX(peakHz,W), H, 'rgba(100,149,237,.6)');
    }
    function drawOct(){
      const ctx = cvs.oct.c.getContext('2d'); const W=ctx.canvas.getBoundingClientRect().width, H=ctx.canvas.getBoundingClientRect().height;
      drawBG(ctx);
      if (!st.dataF||!st.bands.length) return;

      const N=st.dataF.length, fpb=st.sampleRate/(2*N), vals=st.bands.map(b=>{
        const s=Math.max(0,Math.floor(b.fl/fpb)), e=Math.min(N-1,Math.ceil(b.fh/fpb));
        let sum=0,cnt=0; for(let i=s;i<=e;i++){ sum+=st.dataF[i]; cnt++; }
        let v = cnt? sum/cnt : 0;
        if (st.aWeight) v *= 10**(aWeighting(b.fc)/20);
        return v;
      });

      if (st.holdEnabled) for(let i=0;i<vals.length;i++) st.peakOct[i] = Math.max(st.peakOct[i], vals[i]);

      ctx.fillStyle=colors().bar;
      for(let i=0;i<vals.length;i++){
        const b=st.bands[i]; const xL=mapLogX(b.fl,W), xR=mapLogX(b.fh,W), barW=Math.max(2,xR-xL-2);
        const y = mapOctToY(vals[i],H, parseInt(el.octRange.value,10));
        ctx.fillRect(xL+1, y, barW, (H-PAD.B - y));
      }

      ctx.beginPath();
      for(let i=0;i<vals.length;i++){
        const cx=mapLogX(st.bands[i].fc,W), y=mapOctToY(st.peakOct[i]||0,H, parseInt(el.octRange.value,10));
        if (i===0) ctx.moveTo(cx,y); else ctx.lineTo(cx,y);
      }
      ctx.save(); ctx.globalAlpha=.45; ctx.strokeStyle=colors().hold; ctx.lineWidth=1.5; ctx.stroke(); ctx.restore();

      // labels
      let idxNow=0, vNow=-1; for(let i=0;i<vals.length;i++) if (vals[i]>vNow){vNow=vals[i]; idxNow=i;}
      let idxHold=0, vHold=0; for(let i=0;i<st.peakOct.length;i++) if (st.peakOct[i]>vHold){vHold=st.peakOct[i]; idxHold=i;}
      el.octNow.textContent = `Peak: ${fmtHz(st.bands[idxNow].fc)}`;
      if (vHold>0){ el.octHold.style.display=''; el.octHold.textContent = `Hold: ${fmtHz(st.bands[idxHold].fc)}`; drawVLine(ctx, mapLogX(st.bands[idxHold].fc,W), H, colors().hold, true, fmtHz(st.bands[idxHold].fc)); }
      else el.octHold.style.display='none';
      drawVLine(ctx, mapLogX(st.bands[idxNow].fc,W), H, 'rgba(100,149,237,.6)');
    }
    function drawHM(force=false){
      const ctx = cvs.hm.c.getContext('2d'); const W=ctx.canvas.getBoundingClientRect().width, H=ctx.canvas.getBoundingClientRect().height;
      ctx.clearRect(0,0,W,H);

      if (!st.dataF||!st.hmBins.length) return;
      // one time slice
      const frame = st.hmBins.map(bin=>{
        let sum=0,cnt=0; for(let j=bin.b0;j<=bin.b1;j++){ sum += st.dataF[j]; cnt++; }
        return {db: cnt>0? dbfs(sum/cnt) : -100};
      });

      // ATH
      let pkI=0, pk=-Infinity; for(let i=0;i<frame.length;i++){ if (frame[i].db>pk){pk=frame[i].db; pkI=i;} }
      if (pk>st.ath.val){ st.ath={val:pk, bin:pkI}; }
      const athBin = st.hmBins[st.ath.bin]; if (athBin){ const f = (athBin.fStart+athBin.fEnd)/2; el.athText.textContent = `ATH: ${fmtHz(f)}`; }

      st.hmData.unshift(frame); if (st.hmData.length>200) st.hmData.pop();

      // draw (simple rectangles)
      const plotH = H-PAD.B, timeScale = plotH/200;
      for(let i=0;i<st.hmData.length;i++){
        const y = i*timeScale, row = st.hmData[i];
        for(let j=0;j<row.length;j++){
          const xL = mapLogX(st.hmBins[j].fStart,W), xR = mapLogX(st.hmBins[j].fEnd,W);
          const db = row[j].db, t = clamp01((db - (-st.hmRangeMax)) / (0 - (-st.hmRangeMax)));
          const pal = colors().heatmap; let col=pal[0];
          if (t<0.25) col=pal[0]; else if (t<0.5) col=pal[1]; else if (t<0.75) col=pal[2]; else if (t<0.9) col=pal[3]; else col=pal[4];
          ctx.fillStyle=col; ctx.fillRect(xL, y, Math.max(1,xR-xL), timeScale);
        }
      }
      // frame
      ctx.strokeStyle=colors().frame; ctx.strokeRect(PAD.L,0,W-PAD.L-PAD.R,plotH);
      ctx.strokeStyle=colors().gridV;
      [20,31.5,40,50,63,80,100,125,160,200,250,315,400,500,630,800,1000,2000,4000,8000,16000].forEach(t=>{ const x=mapLogX(t,W); ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,plotH); ctx.stroke(); });
      ctx.fillStyle=colors().label; ctx.font='12px system-ui'; ctx.textBaseline='alphabetic';
      [31.5,63,125,250,500,1000,2000,4000,8000,16000].forEach(t=>{ const x=mapLogX(t,W); ctx.fillText(t>=1000?(t/1000)+'k':t, x-8, H-10); });
    }

    function drawVLine(ctx, x, H, color, dashed=false, label=null){
      const y0=PAD.T, y1=H-PAD.B;
      ctx.save(); ctx.strokeStyle=color; ctx.lineWidth=1; if(dashed) ctx.setLineDash([5,5]); ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke(); ctx.restore();
      if (!label) return;
      // pill
      ctx.save(); ctx.font='12px system-ui'; const padX=6; const textW=ctx.measureText(label).width; const boxW=textW+padX*2, boxH=18;
      let bx = Math.round(x - boxW/2), by=y0+2, minX=PAD.L+2, maxX=(ctx.canvas.getBoundingClientRect().width-PAD.R)-boxW-2;
      if (bx<minX) bx=minX; if (bx>maxX) bx=maxX;
      ctx.fillStyle='rgba(0,0,0,.55)'; ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.beginPath();
      const r=8; ctx.moveTo(bx+r,by); ctx.lineTo(bx+boxW-r,by); ctx.quadraticCurveTo(bx+boxW,by,bx+boxW,by+r);
      ctx.lineTo(bx+boxW,by+boxH-r); ctx.quadraticCurveTo(bx+boxW,by+boxH,bx+boxW-r,by+boxH);
      ctx.lineTo(bx+r,by+boxH); ctx.quadraticCurveTo(bx,by+boxH,bx,by+boxH-r); ctx.lineTo(bx,by+r); ctx.quadraticCurveTo(bx,by,bx+r,by);
      ctx.closePath(); ctx.fill(); ctx.stroke();
      ctx.fillStyle=colors().label; ctx.textBaseline='middle'; ctx.textAlign='center'; ctx.fillText(label, bx+boxW/2, by+boxH/2+0.5);
      ctx.restore();
    }

    /* =================== Loop ========================================== */
    function loop(){
      if (!st.running) return;
      st.an.getByteTimeDomainData(st.dataTD);
      st.an.getByteFrequencyData(st.dataF);
      drawFFT(); drawOct(); drawHM();
      st.raf = requestAnimationFrame(loop);
    }

    /* =================== Floating dock actions ========================= */
    el.fStart.addEventListener('click', () => start());
    el.fStop.addEventListener('click', () => stop());
    el.fHold.addEventListener('click', () => { st.holdEnabled = !st.holdEnabled; el.fHold.setAttribute('aria-pressed', st.holdEnabled); });
    el.fClear.addEventListener('click', () => { st.peakF?.fill(0); st.peakOct?.fill(0); });
    el.fAwt.addEventListener('click', () => { st.aWeight = !st.aWeight; el.fAwt.setAttribute('aria-pressed', st.aWeight); drawOct(); });

    /* =================== Fullscreen (with teleport dock) ================ */
    // helper: toggle FS for a card with fallback to pseudo-fullscreen
    function setupFsToggle(btn, card){
      btn.addEventListener('click', async ()=>{
        // already in pseudo?
        if (card.classList.contains('ps-fs')){ card.classList.remove('ps-fs'); resizeAll(); return; }
        // if already in true FS, exit
        if (document.fullscreenElement && (document.fullscreenElement===card)){
          await document.exitFullscreen().catch(()=>{});
          return;
        }
        // try real FS
        if (card.requestFullscreen){
          try{ await card.requestFullscreen(); }catch(_){
            // fallback (mobile or blocked)
            card.classList.add('ps-fs'); resizeAll();
          }
        }else{
          // fallback
          card.classList.add('ps-fs'); resizeAll();
        }
      });
    }
    setupFsToggle(el.btnFsFFT, el.cardFFT);
    setupFsToggle(el.btnFsOCT, el.cardOCT);
    setupFsToggle(el.btnFsSPEC, el.cardSPEC);

    // keep original home for dock (restore when exit)
    const dockHome = el.dock.parentElement;
    const dockNext = el.dock.nextSibling; // may be null

    function moveDockInto(target){
      if (!target) return;
      if (el.dock.parentElement===target) return;
      target.appendChild(el.dock);
      el.dock.classList.add('in-fs');
    }
    function restoreDockHome(){
      if (el.dock.parentElement===dockHome) return;
      if (dockNext && dockNext.parentNode===dockHome) dockHome.insertBefore(el.dock, dockNext);
      else dockHome.appendChild(el.dock);
      el.dock.classList.remove('in-fs');
    }

    // **IMPORTANT**: Teleport dock only when REAL fullscreen is active.
    // On mobile (pseudo/fullscreen not supported), this event won't fire,
    // so the behavior stays exactly the same asเดิม.
    document.addEventListener('fullscreenchange', ()=>{
      const fsEl = document.fullscreenElement;
      if (fsEl){
        // if it's one of our cards, move dock inside
        if (fsEl===el.cardFFT || fsEl===el.cardOCT || fsEl===el.cardSPEC){
          moveDockInto(fsEl);
          // resize canvases for new viewport
          setTimeout(resizeAll, 10);
        }
      }else{
        // exited FS -> put dock back
        restoreDockHome();
        setTimeout(resizeAll, 10);
      }
    });

    /* =================== init ============================== */
    // link canvases & size
    resizeAll();
    document.documentElement.dataset.theme = 'studio-blue'; // default theme

    // click-drag frequency tooltip (FFT & OCT only)
    function attachGuide(canvas, tip){
      let pressed=false;
      const getX = e=>{ const r=canvas.getBoundingClientRect(); const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left; return Math.max(PAD.L,Math.min(r.width-PAD.R,x)); };
      const update = x=>{
        const freq = xToFreq(x, canvas.getBoundingClientRect().width);
        tip.style.display='block'; tip.style.left=x+'px'; tip.style.top='8px'; tip.textContent=fmtHz(freq);
      };
      const clear = ()=>{ pressed=false; tip.style.display='none'; };
      canvas.addEventListener('mousedown', e=>{ pressed=true; e.preventDefault(); update(getX(e)); });
      canvas.addEventListener('mousemove', e=>{ if (!pressed) return; e.preventDefault(); update(getX(e)); });
      ['mouseup','mouseleave'].forEach(ev=>canvas.addEventListener(ev, clear));
      canvas.addEventListener('touchstart', e=>{ pressed=true; update(getX(e)); }, {passive:true});
      canvas.addEventListener('touchmove', e=>{ if (!pressed) return; update(getX(e)); }, {passive:true});
      canvas.addEventListener('touchend', clear);
    }
    attachGuide(el.fftCanvas, el.fftTip);
    attachGuide(el.octCanvas, el.octTip);

  })();
  </script>
</body>
</html>
